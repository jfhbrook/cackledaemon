#+TITLE: Cackledaemon - An Emacs Installation and Runtime Manager for Windows
#+AUTHOR: Josh Holbrook
#+OPTIONS: tags:nil toc:nil

* Introduction :export:
#+BEGIN_QUOTE
Oh-ho-ho! Swirly Photoshop magic! I bet this thing could release some serious
cackledemons!

-- Strong Bad
#+END_QUOTE

Anyone who has used a fully configured [[https://www.gnu.org/software/emacs/][Emacs]] install such as [[https://www.spacemacs.org/][Spacemacs]] or [[https://github.com/hlissner/doom-emacs][Doom]]
knows that Emacs can take a long time to initially boot. This isn't for a lack
of trying - in fact, the source code for Doom is half speed hacks and I highly
encourage anybody hacking on Emacs to take a look.

The truth is that Emacs is less a code editor and more of a *framework* for
*writing text-based applications*. I like to compare it to [[https://nodejs.org][Node.js]] in this
regard, which, while really good at being a webserver is no [[https://www.nginx.com/][NGINX]], but instead a
runtime where you can import lots of tiny pieces of functionality a la carte to
make your own webserver. Any one of these configurations does exactly this - it
installs packages from the internet, requires them and uses [[https://www.gnu.org/software/emacs/manual/html_node/eintr/][Emacs Lisp]] to create
a complete application. Spacemacs and Doom are built similarly, but feel
different because they *are* in fact meaningfully different.

Just as you don't want to load the JavaScript runtime for every request (this is
how non-Node webservers [[https://en.wikipedia.org/wiki/Common_Gateway_Interface][used to do in the olden days]] and trust me it was not
very good) you don't really want to load all of Emacs every time you open a file
either. It's less than ideal.

Luckily for us, Emacs can be ran [[https://www.emacswiki.org/emacs/EmacsAsDaemon][as a daemon]] and connected to via a client,
typically ~emacsclient~. In Linux and [[https://www.freedesktop.org/wiki/Software/systemd/][systemd]] this works seamlessly - often you
can run =systemctl start --user emacs= and be off to the races. In OSX it's only
a little harder - you [[https://www.emacswiki.org/emacs/EmacsAsDaemon#toc8][copy-paste a plist file from the wiki]], pull some very
minor shenanigans and have a mostly working daemon.

In Windows it's a bit more of a mess. This is because the Windows abstractions
for processes and services are wildly divergent from those in nix-like
environments such as Linux and OSX. Init systems like systemd run and manage
normal process, meanwhile in Windows services are in fact [[https://docs.microsoft.com/en-us/dotnet/framework/windows-services/walkthrough-creating-a-windows-service-application-in-the-component-designer][special programs]] that
[[https://docs.microsoft.com/en-us/dotnet/api/system.serviceprocess?view=netframework-4.8][expose an alternate interface]] to that of the standard process. The upshot is
that any standard process that one wants to run as a Windows service needs to be
wrapped in one of these special programs, complete with bespoke abstractions for
process management, log management and so on.

Alternately, arbitrary processes may be [[https://support.microsoft.com/en-us/help/4026268/windows-10-change-startup-apps][configured to start on user login]].
Practically speaking, this is how most persistent applications are ran in
Windows, and in fact the [[https://www.emacswiki.org/emacs/EmacsMsWindowsIntegration#toc8][approach documented in the wiki]] does exactly this - it
uses a Powershell script to generate a very simple [[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands][batch file]] that cleans up
server state from the prior run and then spawns the Emacs daemon.

This works OK. However, there are some downsides. if the Emacs daemon crashes
for any reason, there's no signal other than ~emacsclient~ mysteriously not
working; any logs that come out of the Emacs daemon are lost to the aether; and
straightforward lifecycle actions that can be done casually with systemd (start,
top, restart, status) are very non-ergonomic.

Luckily, [[https://docs.microsoft.com/en-us/powershell/scripting/overview][PowerShell]] has our back. PowerShell is a shockingly good language - it
performs admirably as a shell and yet scales to general purpose use, even being
capable of making proper [[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes][.NET classes]]. More to the point, it's very good at
[[https://docs.microsoft.com/en-us/powershell/scripting/samples/managing-processes-with-process-cmdlets][managing processes]] and has [[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/background-jobs][special support for background jobs]], as well as being
able to [[https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.notifyicon][instantiate and manage tray icons]] via [[https://docs.microsoft.com/en-us/dotnet/framework/winforms/][Windows Forms]]. All it needs is a
little elbow grease!

Cackledaemon is a PowerShell module that intends to be a solution for managing
such an instance of the Emacs daemon for Windows. It includes functions for
starting, stopping and restarting the Emacs daemon, functions and jobs for log
management and rotation, and a tray icon for a lil' point-and-click action and
notifications for if/when Emacs exits unexpectedly.

* Configuration and State
** Working Directory
Cackledaemon needs a place to store configurations, logs and process metadata.
For this purpose, we create a folder at =$Env:AppData\Cackledaemon=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
$CackledaemonWD = Join-Path $Env:AppData 'cackledaemon'
$CackledaemonConfigLocation = Join-Path $CackledaemonWD 'Configuration.ps1'

function New-CackledaemonWD {
    New-Item -Path $CackledaemonWD -ItemType directory

    $ModuleDirectory = Split-Path -Path (Get-Module Cackledaemon).Path -Parent

    @('Configuration.ps1', 'Shortcuts.csv', 'FileTypeAssociations.csv') | ForEach-Object {
        $Source = Join-Path $ModuleDirectory $_
        $Destination = Join-Path $CackledaemonWD $_

        Copy-Item $Source $Destination
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
function Initialize-TestEnvironment {
    $Global:OriginalAppData = $Env:AppData
    $Global:OriginalProgramFiles = $Env:ProgramFiles
    $Global:OriginalModulePath = (Get-Module 'Cackledaemon').Path

    $Env:AppData = "$TestDrive\AppData"
    $Env:ProgramFiles = "$TestDrive\Program Files"

    New-Item $Env:AppData
    New-Item $Env:ProgramFiles

    Remove-Module Cackledaemon -ErrorAction 'SilentlyContinue'
    Import-Module .\Cackledaemon\Cackledaemon.psm1

    $Global:CackledaemonWD = "$TestDrive\Cackledaemon"
    $Global:CackledaemonConfigLocation = "$TestDrive\Cackledaemon\Configuration.ps1"

    New-CackledaemonWD
}

function Restore-StandardEnvironment {
    $Env:AppData = $Global:OriginalAppData
    $Env:ProgramFiles = $Global:OriginalProgramFiles

    Remove-Item "$TestDrive\AppData"
    Remove-Item "$TestDrive\Program Files"
    Remove-Item -Recurse "$TestDrive\Cackledaemon"

    Remove-Module Cackledaemon

    if ($Global:OriginalModulePath) {
        Import-Module $Global:OriginalModulePath
    }
}

Describe "New-CackledaemonWD" {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It "creates a new and initialized working directory" {
        'TestDrive:\Cackledaemon' | Should -Exist
        'TestDrive:\Cackledaemon\Configuration.ps1' | Should -Exist
        'TestDrive:\Cackledaemon\Shortcuts.csv' | Should -Exist
        'TestDrive:\Cackledaemon\FileTypeAssociations.csv' | Should -Exist
    }
}

#+END_SRC
** Base Config File
Most Cackledaemon settings live in ~Configuration.ps1~. These settings can be
loaded by sourcing the script.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Configuration.ps1
# Installer Settings
$WorkspaceDirectory = Join-Path $CackledaemonWD 'Workspace'
$EmacsDownloadsEndpoint = 'https://ftp.gnu.org/gnu/emacs/windows/'
$EmacsInstallLocation = Join-Path $Env:ProgramFiles 'emacs'
$StartMenuPath = Join-Path $Env:AppData 'Microsoft\Windows\Start Menu\Programs\Gnu Emacs'

# Logging Settings
$CackledaemonLogFile = Join-Path $CackledaemonWD 'Cackledaemon.log'
$EmacsStdOutLogFile = Join-Path $CackledaemonWD 'EmacsStdOut.log'
$EmacsStdErrLogFile = Join-Path $CackledaemonWD 'EmacsStdErr.log'
$LogSize = 1mb
$LogRotate = 4
$LogCheckTime = 60  # Seconds

# Applet Settings
$NotifyTimeout = 5000
#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Configuration.ps1' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'defines base settings' {
        . $CackledaemonConfigLocation

        $WorkspaceDirectory | Should -Be "$TestDrive\Cackledaemon\Workspace"
        $EmacsDownloadsEndpoint | Should -Be 'https://ftp.gnu.org/gnu/emacs/windows/'
        $EmacsInstallLocation | Should -Be "$TestDrive\Program Files\emacs"
        $StartMenuPath | Should -Be "$TestDrive\AppData\Microsoft\Windows\Start Menu\Programs\Gnu Emacs"

        $CackledaemonLogFile | Should -Be "$TestDrive\Cackledaemon\Cackledaemon.log"
        $EmacsStdOutLogFile | Should -Be "$TestDrive\Cackledaemon\EmacsStdOut.log"
        $EmacsStdErrLogFile | Should -Be "$TestDrive\Cackledaemon\EmacsStdErr.log"
        $LogSize | Should -Be 1mb
        $LogRotate | Should -Be 4
        $LogCheckTime | Should -Be 60

        $NotifyTimeout | Should -Be 5000
    }
}

#+END_SRC
** Start Menu Shortcuts Config
The desired state of Start menu shortcuts are stored in a CSV file. Note that
the ~TYPE~ header is necessary, and the ~$ArgumentList~ is double-encoded as a
JSON array.

#+BEGIN_SRC csv :tangle ./Cackledaemon/Shortcuts.csv
#TYPE ShortcutCsvRecord
"ShortcutName","EmacsBinaryName","ArgumentList","Description"
Emacs Client,emacsclientw.exe,"[]",Open the Emacs Client
#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
class ShortcutCsvRecord {
    [string]$ShortcutName
    [string]$EmacsBinaryName
    [string]$ArgumentList
    [string]$Description

    ShortcutCsvRecord(
        [string]$ShortcutName,
        [string]$EmacsBinaryName,
        [string]$ArgumentList,
        [string]$Description
    ) {
        $this.ShortcutName = $ShortcutName
        $this.EmacsBinaryName = $EmacsBinaryName
        $this.ArgumentList = $ArgumentList
        $this.Description = $Description
    }
}

class ShortcutRecord {
    [string]$ShortcutName
    [string]$EmacsBinaryName
    [string[]]$ArgumentList
    [string]$Description

    ShortcutRecord(
        [string]$ShortcutName,
        [string]$EmacsBinaryName,
        [string[]]$ArgumentList,
        [string]$Description
    ) {
        $this.ShortcutName = $ShortcutName
        $this.EmacsBinaryName = $EmacsBinaryName
        $this.ArgumentList = $ArgumentList
        $this.Description = $Description
    }
}

function Get-ShortcutsConfig {
    Import-Csv -Path (Join-Path $CackledaemonWD './Shortcuts.csv') | ForEach-Object {
        New-Object ShortcutRecord $_.ShortcutName, $_.EmacsBinaryName, ($_.ArgumentList | ConvertFrom-Json), $_.Description
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Get-ShortcutsConfig' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'loads shortcuts settings' {
        $Config = Get-ShortcutsConfig

        $Config | Should -Not -Be $null

        $Config.length | Should -Be 1

        $Config[0].ShortcutName | Should -Be 'Emacs Client'
        $Config[0].EmacsBinaryName | Should -Be 'emacsclientw.exe'
        $Config[0].ArgumentList | Should -Be @()
        $Config[0].Description | Should -Be 'Open the Emacs Client'
    }
}

#+END_SRC
** File Type Associations Config
Desired file type associations are also stored in a CSV file. Note that the
~TYPE~ header is necessary. The format of the command string is detailed in [[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/ftype][the
documentation for the ~ftype~ batch command.]]

#+BEGIN_SRC csv :tangle ./Cackledaemon/FileTypeAssociations.csv
#Type FileTypeAssociationCsvRecord
"FileType","Extension","Command"
Gnu.Emacs.Org,.org,emacsclientw.exe -c %1
Gnu.Emacs.ELisp,.el,emacsclientw.exe -c %1
#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
class FileTypeAssociationRecord {
    [string]$FileType
    [string]$Extension
    [string]$Command

    FileTypeAssociationRecord(
        [string]$FileType,
        [string]$Extension,
        [string]$Command
    ) {
        $this.FileType = $FileType
        $this.Extension = $Extension
        $this.Command = $Command
    }
}

class FileTypeAssociationCsvRecord : FileTypeAssociationRecord {
    FileTypeAssociationCsvRecord([string]$FileType, [string]$Extension, [string]$Command): base($FileType, $Extension, $Command) {}
}

function Get-FileTypeAssociationsConfig {
    Import-Csv -Path (Join-Path $CackledaemonWD './FileTypeAssociations.csv') | ForEach-Object {
        New-Object FileTypeAssociationRecord $_.FileType, $_.Extension, $_.Command
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Get-FileTypeAssociationsConfig' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'loads file type association settings' {
        $Config = Get-FileTypeAssociationsConfig

        $Config | Should -Not -Be $null

        $Config.length | Should -Be 2

        $Config[0].FileType | Should -Be 'Gnu.Emacs.Org'
        $Config[0].Extension | Should -Be '.org'
        $Config[0].Command | Should -Be 'emacsclientw.exe -c %1'

        $Config[1].FileType | Should -Be 'Gnu.Emacs.ELisp'
        $Config[1].Extension | Should -Be '.el'
        $Config[1].Command | Should -Be 'emacsclientw.exe -c %1'
    }
}
#+END_SRC
* Job Management
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Enable-CackledaemonJob {
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [string]$Name,
        [Parameter(Position=1)]
        [ScriptBlock]$ScriptBlock
    )

    $Job = Get-Job -Name $Name -ErrorAction SilentlyContinue

    if ($Job) {
        Write-LogWarning ('{0} job already exists. Trying to stop and remove...' -f $Name)
            Disable-CackledaemonJob -Name $Job.Name -ErrorAction Stop

    }

    $Job = Get-Job -Name $Name -ErrorAction SilentlyContinue

    if ($Job) {
        Write-LogError -Message ('{0} job somehow still exists - not attempting to start a new one.' -f $Name) `
          -Category 'ResourceExists' `
          -CategoryActivity 'Enable-CackledaemonJob' `
          -CategoryReason 'UnstoppableJobException'
    } else {
        Start-Job `
          -Name $Name `
          -InitializationScript {
              Import-Module Cackledaemon
          } `
          -ScriptBlock $ScriptBlock
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe "Enable-CackledaemonJob" {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context "when a job doesn't exist" {
        It "creates a new job" {
            Stop-Job -Name 'testJob' -ErrorAction SilentlyContinue
            Remove-Job -Name 'testJob' -ErrorAction SilentlyContinue

            Enable-CackledaemonJob "testJob" {} -ErrorAction Stop

            $Job = Get-Job -Name 'testJob'
            $Job | Should -Not -Be $null

            Stop-Job -Id $Job.Id
            Remove-Job -Id $Job.Id
        }
    }

    Context "when a job already exists" {
        It 'disables and then creates a new job' {
            Stop-Job -Name 'testJob' -ErrorAction SilentlyContinue
            Remove-Job -Name 'testJob' -ErrorAction SilentlyContinue

            Start-Job -Name 'testJob' -ScriptBlock {}

            Enable-CackledaemonJob "testJob" {} -ErrorAction Stop -WarningVariable Warnings 3> $null

            $Warnings | Should -Not -Be $null
            $Warnings.Count | Should -Be 1

            $Warnings[0].ToString() | Should -Be "testJob job already exists. Trying to stop and remove..."

            $Job = Get-Job -Name 'testJob'

            $Job | Should -Not -Be $null
            $Job.length | Should -Be 1

            Stop-Job -Id $Job.Id
            Remove-Job -Id $Job.Id
        }
    }
}
#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Disable-CackledaemonJob {
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [string]$Name
    )

    $Job = Get-Job -Name $Name -ErrorAction SilentlyContinue

    if (-not $Job) {
        Write-LogWarning ("{0} job doesn't exist. Doing nothing." -f $Name)
        return
    }

    try {
        Stop-Job -Name $Name -ErrorAction Stop
        Remove-Job -Name $Name -ErrorAction Stop
    } catch {
        Write-LogError -Message ('Failed to stop and remove {0} job.' -f $Name) `
            -Exception $_.Exception `
            -Category $_.CategoryInfo.Category `
            -CategoryActivity $_.CategoryInfo.Activity `
            -CategoryReason $_.CategoryInfo.Reason `
            -CategoryTargetName $_.CategoryInfo.TargetName `
            -CategoryTargetType $_.CategoryInfo.TargetType
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe "Disable-CackledaemonJob" {
    Context "when a job exists" {
        It "disables the job" {
            Initialize-TestEnvironment

            Stop-Job -Name 'testJob' -ErrorAction SilentlyContinue
            Remove-Job -Name 'testJob' -ErrorAction SilentlyContinue

            Start-Job -Name 'testJob' -ScriptBlock {}

            Disable-CackledaemonJob "testJob" -ErrorAction Stop

            $Job = Get-Job -Name 'testJob' -ErrorAction SilentlyContinue
            $Job | Should -Be $null
        }
    }

    Context "when a job has already been removed" {
        It 'does nothing' {
            Initialize-TestEnvironment

            Stop-Job -Name 'testJob' -ErrorAction SilentlyContinue
            Remove-Job -Name 'testJob' -ErrorAction SilentlyContinue

            Disable-CackledaemonJob "testJob" -ErrorAction Stop -WarningVariable Warnings 3> $null

            $Warnings | Should -Not -Be $null
            $Warnings.length | Should -Be 1

            $Warnings[0].ToString() | Should -Be "testJob job doesn't exist. Doing nothing."

            $Job = Get-Job -Name 'testJob' -ErrorAction SilentlyContinue

            $Job | Should -Be $null
        }
    }
}
#+END_SRC
* Logging
** Logger
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Write-Log {
    param(
        [Parameter(Position=0)]
        [string]$Message,
        [string]$Level = 'Verbose',
        [Exception]$Exception,
        [System.Management.Automation.ErrorCategory]$Category = 'NotSpecified',
        [string]$CategoryActivity,
        [string]$CategoryReason,
        [string]$CategoryTargetName,
        [string]$CategoryTargetType
    )

    Try {
        . $CackledaemonConfigLocation
    } Catch {
        Write-Warning 'Unable to load configuration! Unable to write to log file.'
    }

    if (-not @('Debug', 'Verbose', 'Information', 'Warning', 'Error').Contains($Level)) {
        Write-LogWarning ('Write-Log called with unrecognized level {0}' -f $Level)
        $Level = 'Warning'
    }

    if ($Level -eq 'Error' -and $Exception) {
        $Message = ('{0} (Exception: {1})' -f $Message, $Exception)
    }

    $Line = ('[{0}] {1}: {2}' -f (Get-Date -Format o), $Level, $Message)

    if ($CackledaemonLogFile) {
        Add-Content $CackledaemonLogFile -Value $Line
    }

    if ($Level -eq 'Debug') {
        Write-Debug $Message
    }
    if ($Level -eq 'Information') {
        Write-Information $Message
    } elseif ($Level -eq 'Verbose') {
        Write-Verbose $Message
    } elseif ($Level -eq 'Warning') {
        Write-Warning $Message
    } elseif ($Level -eq 'Error') {
        if ($Exception) {
            Write-Error -Message $Message `
              -Exception $Exception `
              -Category $Category `
              -CategoryActivity $CategoryActivity `
              -CategoryReason $CategoryReason `
              -CategoryTargetName $CategoryTargetName `
              -CategoryTargetType $CategoryTargetType
        } else {
            Write-Error -Message $Message `
              -Category $Category `
              -CategoryActivity $CategoryActivity `
              -CategoryReason $CategoryReason `
              -CategoryTargetName $CategoryTargetName `
              -CategoryTargetType $CategoryTargetType
        }
    }
}

function Write-LogDebug {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Debug
}

function Write-LogInformation {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Information
}

function Write-LogVerbose {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Verbose
}

function Write-LogWarning {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Warning
}

function Write-LogError {
    param(
        [Parameter(Position=0)]
        [string]$Message,
        [Exception]$Exception,
        [System.Management.Automation.ErrorCategory]$Category = 'NotSpecified',
        [string]$CategoryActivity,
        [string]$CategoryReason,
        [string]$CategoryTargetName,
        [string]$CategoryTargetType
    )

    if ($Exception) {
        Write-Log -Level Error `
          -Message $Message `
          -Exception $Exception `
          -Category $Category `
          -CategoryActivity $CategoryActivity `
          -CategoryReason $CategoryReason `
          -CategoryTargetName $CategoryTargetName `
          -CategoryTargetType $CategoryTargetType
    } else {
        Write-Log -Level Error `
          -Message $Message `
          -Category $Category `
          -CategoryActivity $CategoryActivity `
          -CategoryReason $CategoryReason `
          -CategoryTargetName $CategoryTargetName `
          -CategoryTargetType $CategoryTargetType
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
$TimestampRegexp = '\[\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{7}-\d{2}:\d{2}\]'

Describe 'Write-Log' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when the configuration is missing' {
        It 'warns and does nothing' {
            Remove-Item $CackledaemonConfigLocation

            Write-Log -Message "test log" -WarningVariable Warnings 3> $null

            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -Not -Exist

            $Warnings | Should -Not -Be $null
            $Warnings.Count | Should -Be 1
            $Warnings[0].ToString() | Should -Be 'Unable to load configuration! Unable to write to log file.'
        }
    }

    Context 'when called with an unrecognized level' {
        It 'warns and then logs at the warning level' {
            Write-Log -Level 'InvalidLevel' -Message 'Test Message' -WarningVariable Warnings 3> $null

            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -FileContentMatch "^$TimestampRegexp Warning: Write-Log called with unrecognized level InvalidLevel$"
            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -FileContentMatch "^$TimestampRegexp Warning: Test Message$"

            $Warnings | Should -Not -Be $null
            $Warnings.Count | Should -Be 2

            $Warnings[0].ToString() | Should -Be 'Write-Log called with unrecognized level InvalidLevel'
            $Warnings[1].ToString() | Should -Be 'Test Message'
        }
    }
}

@('Debug', 'Verbose', 'Information', 'Warning') | ForEach-Object {
    Describe ('Write-Log{0}' -f $_) {
        BeforeEach {
            Initialize-TestEnvironment
        }

        AfterEach {
            Restore-StandardEnvironment
        }

        It ('logs at the {0} level' -f $_) {
            Invoke-Expression "Write-Log${_} 'Test message'" 3> $null

            "$TestDrive/Cackledaemon/Cackledaemon.log" | Should -FileContentMatch "^$TimestampRegexp ${_}: Test message$"
        }
    }
}

Describe 'Write-LogError' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when called with an exception type' {
        It 'logs an error' {
            $Exception = New-Object Exception 'Test exception'

            Write-LogError `
              'Test message' `
              -Exception (New-Object Exception 'Test exception') `
              -Category 'InvalidOperation' `
              -CategoryActivity 'Logging with an exception' `
              -CategoryReason 'Testing' `
              -CategoryTargetName 'SomeTarget' `
              -CategoryTargetType 'SomeTargetType' 2> $null

            $Error[0].ToString() | Should -Be 'Test message (Exception: System.Exception: Test exception)'
            $Error[0].CategoryInfo.Category.ToString() | Should -Be 'InvalidOperation'
            $Error[0].CategoryInfo.Reason | Should -Be 'Testing'
            $Error[0].CategoryInfo.TargetName | Should -Be 'SomeTarget'
            $Error[0].CategoryInfo.TargetType | Should -Be 'SomeTargetType'

            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -Exist
            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -FileContentMatch "^$TimestampRegexp Error: Test message \(Exception: System.Exception: Test exception\)$"
        }
    }

    Context 'when called without an exception type' {
        It 'logs an error' {
            Write-LogError `
              'Test message' `
              -Category 'InvalidOperation' `
              -CategoryActivity 'Logging without an exception' `
              -CategoryReason 'Testing' `
              -CategoryTargetName 'SomeTarget' `
              -CategoryTargetType 'SomeTargetType' 2> $null

            $Error[0].Exception | Should -Not -Be $null
            $Error[0].CategoryInfo.Category.ToString() | Should -Be 'InvalidOperation'
            $Error[0].CategoryInfo.Reason | Should -Be 'Testing'
            $Error[0].CategoryInfo.TargetName | Should -Be 'SomeTarget'
            $Error[0].CategoryInfo.TargetType | Should -Be 'SomeTargetType'

            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -Exist
            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -FileContentMatch "^$TimestampRegexp Error: Test Message$"
        }
    }
}


#+END_SRC
** Log Rotation
This function more or less tries to emulate a typical logrotate config - it
rotates the log if it's at or over a certain size, retains some finite count of
log files, and drops the last one if necessary.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Invoke-LogRotate {
    [CmdletBinding()]
    param()

    . $CackledaemonConfigLocation

    @($CackledaemonLogFile, $EmacsStdoutLogFile, $EmacsStdErrLogFile) | ForEach-Object {
        $LogFile = $_

        if ((Test-Path $LogFile) -and (Get-Item $LogFile).Length -ge $LogSize) {
            Write-LogVerbose ('Rotating {0}...' -f $LogFile)

            ($LogRotate..0) | ForEach-Object {
                $Current = $(if ($_) {
                    '{0}.{1}' -f $LogFile, $_
                } else { $LogFile })

                $Next = '{0}.{1}' -f $LogFile, ($_ + 1)

                if (Test-Path $Current) {
                    Write-Log ('Copying {0} to {1}...' -f $Current, $Next)

                    Copy-Item -Path $Current -Destination $Next
                }
            }

            Write-LogVerbose ('Truncating {0}...' -f $LogFile)

            Clear-Content $LogFile

            $StaleLogFile = '{0}.{1}' -f $LogFile, ($LogRotate + 1)

            if (Test-Path $StaleLogFile) {
                Write-LogVerbose ('Removing {0}...' -f $StaleLogFile)

                Remove-Item $StaleLogFile
            }

            Write-LogVerbose 'Done.'
        }
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Invoke-LogRotate' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'rotates the logs' {
        Add-Content 'TestDrive:\Cackledaemon\Configuration.ps1' '$LogSize = 1'
        Add-Content 'TestDrive:\Cackledaemon\Configuration.ps1' '$LogRotate = 2'

        Write-LogVerbose 'Testing 1'

        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -FileContentMatch 'Testing 1'
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -Not -Exist
        'TestDrive:\Cackledaemon\EmacsStdOut.log' | Should -Not -Exist
        'TestDrive:\Cackledaemon\EmacsStdErr.log' | Should -Not -Exist

        Invoke-LogRotate

        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Not -FileContentMatch 'Testing 1'
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -FileContentMatch 'Testing 1'

        Write-LogVerbose 'Testing 2'
        Invoke-LogRotate

        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Not -FileContentMatch 'Testing 2'
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -FileContentMatch 'Testing 2'
        'TestDrive:\Cackledaemon\Cackledaemon.log.2' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log.2' | Should -FileContentMatch 'Testing 1'

        Write-LogVerbose 'Testing 3'
        Invoke-LogRotate

        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Not -FileContentMatch 'Testing 3'
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -FileContentMatch 'Testing 3'
        'TestDrive:\Cackledaemon\Cackledaemon.log.2' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log.2' | Should -FileContentMatch 'Testing 2'
        'TestDrive:\Cackledaemon\Cackledaemon.log.3' | Should -Not -Exist
    }
}

#+END_SRC

We can also use a job to manage log rotation.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Enable-LogRotateJob {
    [CmdletBinding()]
    param()

    Enable-CackledaemonJob 'LogRotateJob' {
        . $CackledaemonConfigLocation

        while ($True) {
            Invoke-LogRotate
            Write-LogDebug ('LogRotateJob sleeping for {0} seconds.' -f $LogCheckTime)
            Start-Sleep -Seconds $LogCheckTime
        }
    }
}

function Disable-LogRotateJob {
    [CmdletBinding()]
    param()

    Disable-CackledaemonJob 'LogRotateJob'
}

#+END_SRC
* Installing Emacs
** Gotchas and Caveats
On a certain level, installing Emacs is a matter of downloading an official zip
file and unpacking it into the system's ~Program Files~ directory. Beyond that,
we can register executables with Windows, set some environment variables,
populate the Start menu, and configure file type associations.

Emacs is fundamentally designed to run on Unix-like systems, meaning that
sometimes the way Windows works violates Emacs' base expectations. This
introduces a few surprises and caveats. Most of these are handled by
Cackledaemon and the details can be found under the relevant sub-headings.
Others, however, are left as an exercise for the reader.

First, ~emacs.exe~ and ~emacsclient.exe~ are written such that they write to
stdout/stderr, but Windows will run programs that try to do this with a
console. To work around this, Emacs ships with ~runemacs.exe~ and
~emacsclientw.exe~, respectively, which wrap the standard entry points in
Windows-specific ones.

Given no other signal, Emacs will open in =/WINDOWS/system32= by default. There
are a number of ways around this:

- Open Emacs inside of a PowerShell or cmd prompt - in this case, Emacs will
  open in the current working directory
- Add a =cd= call to your Emacs config, which will change Emacs' working
  directory whenever it is loaded
- Set the =default-directory= variable in your Emacs config. This will cause
  Emacs to default to opening in that directory when there isn't an associated
  current working directory
- If opening Emacs with a shortcut, the starting directory of that shortcut may
  be set to the desired directory

File associations - that is, what programs Windows will use to try to open
things like org files and so on - can only be made with ~.exe~, ~.bat~, ~.com~
and ~.pif~ files. This means that if you want to have files opened by Emacs
given specific CLI flags via the "Open With..." menu - for example - that you
will either need to write compiled code or batch scripts.

For more details, refer to:

- [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Startup.html][Windows Startup]] in the Emacs manual
- [[https://git.savannah.gnu.org/cgit/emacs.git/tree/nt/][The nt directory]] in Emacs' source tree, particularly ~runemacs.c~ and ~addpm.c~
- [[https://www.emacswiki.org/emacs/MsWindowsInstallation][MS Windows Installation]] in the Emacs wiki
- [[https://www.emacswiki.org/emacs/EmacsMsWindowsIntegration][Emacs MS Windows Integration]] in the Emacs wiki

** Checking if Emacs is Already Installed
One check we can do to see if Emacs is already installed is to see if
~emacs.exe~ is in the expected location given a configured
=$EmacsInstallLocation=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Test-EmacsExe {
    . $CackledaemonConfigLocation

    Test-Path (Join-Path $EmacsInstallLocation 'bin\emacs.exe')
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Test-EmacsExe' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'searches for emacs.exe in the correct location' {
        Mock -ModuleName Cackledaemon Test-Path { $True }

        Test-EmacsExe | Should -Be $True

        Assert-MockCalled -ModuleName Cackledaemon Test-Path `
          -Times 1 `
          -ParameterFilter { $Path -eq "$TestDrive\Program Files\emacs\bin\emacs.exe"}
    }
}

#+END_SRC
** Versions
Emacs exposes versions of the form ~{major).{minor}~. We use a class to
represent these versions and to do basic comparisons between them.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
class Version : IComparable {
    [int]$Major
    [int]$Minor

    Version([int64]$Major, [int64]$Minor) {
        $this.Major = $Major
        $this.Minor = $Minor
    }

    [int]CompareTo([object]$Other) {
        if ($Other -eq $null) {
            return 1
        }

        $Other = [Version]$Other

        if ($this.Major -gt $Other.Major) {
            return 1
        } elseif ($this.Major -lt $Other.Major) {
            return -1
        } elseif ($this.Minor -gt $Other.Minor) {
            return 1
        } elseif ($this.Minor -lt $Other.Minor) {
            return -1
        } else {
            return 0
        }
    }

    [string]ToString() {
        return 'v{0}.{1}' -f $this.Major, $this.Minor
    }
}

function New-Version {
    param(
        [Parameter(Position=0)]
        [int]$Major,
        [Parameter(Position=1)]
        [int]$Minor
    )

    return New-Object Version $Major, $Minor
}

#+END_SRC

The Emacs bin will report versions if installed. We can grep them out, and
otherwise fall back to reporting a null version, which will usually do the right
thing when compared to a =Version= instance.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Get-EmacsExeVersion {
    if (Test-EmacsExe) {
        . $CackledaemonConfigLocation

        $EmacsExe = Join-Path $EmacsInstallLocation 'bin\emacs.exe'
        if ((Invoke-Expression "$EmacsExe --version")[0] -match '^GNU Emacs (\d+)\.(\d+)$') {
            New-Version $Matches[1], $Matches[2]
        }
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Get-EmacsExeVersion' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when emacs is installed' {
        It 'returns a version' {
            Mock -ModuleName Cackledaemon Test-EmacsExe { $True }
            Mock -ModuleName Cackledaemon Invoke-Expression {
                return 'GNU Emacs 26.2
Copyright (C) 2019 Free Software Foundation, Inc.
GNU Emacs comes with ABSOLUTELY NO WARRANTY.
You may redistribute copies of GNU Emacs
under the terms of the GNU General Public License.
For more information about these matters, see the file named COPYING.'
            }

            $Version = Get-EmacsExeVersion

            Assert-MockCalled -ModuleName Cackledaemon Test-EmacsExe -Times 1
            Assert-MockCalled -ModuleName Cackledaemon Invoke-Expression `
              -Times 1 `
              -ParameterFilter { $Command -eq "$TestDrive\Program Files\emacs\bin\emacs.exe --version" }
        }
    }
}

#+END_SRC
** Official Downloads
Emacs hosts downloads on an Apache webserver running [[https://trisquel.info/][Trisquel Linux]], which I
personally find charming. It turns out that Apache directory listings can be
casually scraped by PowerShell.

It's also worth noting that Cackledaemon only attempts to handle native Windows
x86_64 builds. The first major version of Emacs with such builds is Emacs 25.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
class Download : IComparable {
    [Version]$Version
    [string]$Href

    Download([int64]$Major, [int64]$Minor, [string]$Href) {
        $this.Version = New-Object Version $Major, $Minor
        $this.Href = $Href
    }

    [int]CompareTo([object]$Other) {
        if ($Other -eq $null) {
            return 1
        }

        $Other = [Download]$Other

        return $this.Version.CompareTo($Other.Version)
    }

    [string]ToString() {
        return 'Download($Version={0}; $Href={1})' -f $this.Version, $this.Href
    }
}

function New-Download {
    param(
        [int]$Major,
        [int]$Minor,
        [string]$Href
    )

    New-Object Download $Major, $Minor, $Href
}

function Get-EmacsDownload {
    . $CackledaemonConfigLocation

    Write-LogVerbose ('Checking {0} for available Emacs versions...' -f $EmacsDownloadsEndpoint)
    return (Invoke-WebRequest $EmacsDownloadsEndpoint).Links | ForEach-Object {
        if ($_.href -match '^emacs-(\d+)/$') {
            $MajorPathPart = $_.href

            if ([int]$Matches[1] -lt 25) {
                return
            }

            (Invoke-WebRequest ($EmacsDownloadsEndpoint + $MajorPathPart)).Links | ForEach-Object {
                 if ($_.href -match '^emacs-(\d+)\.(\d+)-x86_64\.zip$') {
                     $Href = $EmacsDownloadsEndpoint + $MajorPathPart + $_.href
                     return New-Download $Matches[1] $Matches[2] $Href
                 }
            }
        }
    } | Where-Object {$_}
}

function Get-LatestEmacsDownload {
    (Get-EmacsDownload | Measure-Object -Maximum).Maximum
}

#+END_SRC

This test was *way* too difficult to write lmao!

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Get-EmacsDownload' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'fetches emacs downloads' {
        Mock -ModuleName Cackledaemon Invoke-WebRequest {
            if (-not (Test-Path '.\Tapes')) {
                New-Item -Type Directory '.\Tapes'
            }

            $TapePath = Join-Path '.\Tapes' ('{0}.json' -f [uri]::EscapeDataString($Uri))
            $Curl = Get-Command Invoke-WebRequest -CommandType Cmdlet

            if (Test-Path $TapePath) {
                return (Get-Content $TapePath | ConvertFrom-Json)
            } else {
                $Result = & $Curl $Uri
                $Result | ForEach-Object {
                    @{
                        Links=$_.Links
                    }
                } | ConvertTo-Json | Set-Content -Path $TapePath
                return $Result
            }
        }

        $Downloads = Get-EmacsDownload
        $Downloads | Should -Not -Be $null
        $Downloads.Count | Should -BeGreaterOrEqual 1
        $Downloads | ForEach-Object {
            $_.Href | Should -Not -Be $null
            $_.Version | Should -Not -Be $null
        }
    }
}

Describe 'Get-LatestEmacsDownload' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'reports the latest emacs download' {
        Mock -ModuleName Cackledaemon Get-EmacsDownload {
            New-Download 1 3 '1.3'
            New-Download 2 1 '2.1'
            New-Download 2 2 '2.2'
        }

        $LatestDownload = Get-LatestEmacsDownload
        $LatestDownload | Should -Not -Be $null
        $LatestDownload.Href | Should -Not -Be $null
        $LatestDownload.Version | Should -Not -Be $null
        $LatestDownload.Version.Major | Should -Be 2
        $LatestDownload.Version.Minor | Should -Be 2
    }
}

#+END_SRC
** Workspace Management
In order to effectively download, unpack and install Emacs downloads, we need a
directory to store everything. We use a class to represent the components of the
required directory structure and some helper functions to manage setup and teardown.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
class Workspace {
    [System.IO.DirectoryInfo]$Root
    [System.IO.DirectoryInfo]$Archives
    [System.IO.DirectoryInfo]$Installs
    [System.IO.DirectoryInfo]$Backups

    Workspace([string]$Path) {
        $ArchivesPath = Join-Path $Path 'Archives'
        $InstallsPath = Join-Path $Path 'Installs'
        $BackupsPath = Join-Path $Path 'Backups'

        $this.Root = Get-Item $Path
        $this.Archives = Get-Item $ArchivesPath
        $this.Installs = Get-Item $InstallsPath
        $this.Backups = Get-Item $BackupsPath
    }

    [string]GetKey([Version]$Version) {
        return 'emacs-{0}.{1}-x86_64' -f $Version.Major, $Version.Minor
    }

    [string]GetArchivePath([Version]$Version) {
        return Join-Path $this.Archives ('{0}.zip' -f $this.GetKey($Version))
    }

    [boolean]TestArchive([Version]$Version) {
        return Test-Path $this.GetArchivePath($Version)
    }

    [System.IO.FileInfo]GetArchive([Version]$Version) {
        return Get-Item $this.GetArchivePath($Version)
    }

    [string]GetInstallPath([Version]$Version) {
        return Join-Path $this.Installs $this.GetKey($Version)
    }

    [boolean]TestInstall([Version]$Version) {
        return Test-Path $this.GetInstallPath($Version)
    }

    [System.IO.DirectoryInfo]GetInstall([Version]$Version) {
        return Get-Item $this.GetInstallPath($Version)
    }

    Clear() {
        $this.Root = $null
        $this.Archives = $null
        $this.Installs = $null
        $this.Backups = $null
    }
}

function Test-Workspace {
    . $CackledaemonConfigLocation

    Test-Path $WorkspaceDirectory
}

function Get-Workspace {
    . $CackledaemonConfigLocation

    return New-Object Workspace $WorkspaceDirectory
}

function New-Workspace {
    . $CackledaemonConfigLocation

    $ArchivesPath = Join-Path $WorkspaceDirectory 'Archives'
    $InstallsPath = Join-Path $WorkspaceDirectory 'Installs'
    $BackupsPath = Join-Path $WorkspaceDirectory 'Backups'

    New-Item -Type Directory $WorkspaceDirectory | Out-Null

    New-Item -Type Directory $ArchivesPath | Out-Null
    New-Item -Type Directory $InstallsPath | Out-Null
    New-Item -Type Directory $BackupsPath | Out-Null

    return New-Object Workspace $WorkspaceDirectory
}

function Remove-Workspace {
    $Workspace = Get-Workspace

    Remove-Item $Workspace.Root -Recurse

    $Workspace.Clear()
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Workspace' {
    $TestVersion = New-Version 26 3
    $TestKey = 'emacs-26.3-x86_64'
    $TestArchive = "$TestDrive\Cackledaemon\Workspace\Archives\emacs-26.3-x86_64.zip"
    $TestInstall = "$TestDrive\Cackledaemon\Workspace\Installs\emacs-26.3-x86_64"
    $TestWorkspace = $null

    BeforeEach {
        Initialize-TestEnvironment
        $TestWorkspace = New-Workspace
    }

    AfterEach {
        Remove-Workspace
        Restore-StandardEnvironment
    }

    It 'contains the expected directories' {
        'TestDrive:\Cackledaemon\Workspace' | Should -Exist
        'TestDrive:\Cackledaemon\Workspace\Archives' | Should -Exist
        'TestDrive:\Cackledaemon\Workspace\Installs' | Should -Exist
        'TestDrive:\Cackledaemon\Workspace\Backups' | Should -Exist
    }

    It 'can get an existing workspace' {
        Get-Workspace | Should -Not -Be Null
    }

    It 'can generate a key from a version' {
        $TestWorkspace.GetKey($TestVersion) | Should -Be 'emacs-26.3-x86_64'
    }

    It 'can generate an archive path from a version' {
        $TestWorkspace.GetArchivePath($TestVersion) | Should -Be $TestArchive
    }

    Context "when an archive doesn't exist" {
        It 'can test an archive path from a version' {
            $TestWorkspace.TestArchive($TestVersion) | Should -Be $False
        }
    }

    Context 'when an archive exists' {
        BeforeEach {
            New-Item $TestArchive
        }

        It 'can test an archive path from a version' {
            $TestWorkspace.TestArchive($TestVersion) | Should -Be $True
        }

        It 'can get an archive from a version' {
            $TestWorkspace.GetArchive($TestVersion) | Should -Not -Be $null
        }
    }

    It 'can generate an install path from a version' {
        $TestWorkspace.GetInstallPath($TestVersion) | Should -Be $TestInstall
    }

    Context "when an install doesn't exist" {
        It 'can test an install path from a version' {
            $TestWorkspace.TestInstall($TestVersion) | Should -Be $False
        }
    }

    Context 'when an install exists' {
        BeforeEach {
            New-Item -Type Directory $TestInstall
        }

        It 'can test an install path from a version' {
            $TestWorkspace.TestInstall($TestVersion) | Should -Be $True
        }

        It 'can get an install from a version' {
            $TestWorkspace.GetInstall($TestVersion) | Should -Not -Be $null
        }
    }
}
#+END_SRC

** Downloading and Extracting
Given a workspace and an upstream download, we can use =Invoke-WebRequest= to
download the zip files, =Extract-Archive= to unpack them and some filesystem
operations to put them in place.

Note that by default this installs Emacs in ~Program Files~ and so will need
Administrator privileges.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function New-EmacsArchive {
    param(
        [Parameter(Position=0)]
        [Download]$Download
    )

    $Workspace = Get-Workspace

    $Archive = $Workspace.GetArchivePath($Download.Version)

    Invoke-WebRequest `
      -Uri $Download.Href `
      -OutFile $Archive | Out-Null

    return Get-Item $Archive
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'New-EmacsArchive' {
    $TestWorkspace = $null
    $TestDownload = New-Download 26 3 'https:\\test_url'
    $ArchivePath = "$TestDrive\Cackledaemon\Workspace\Archives\emacs-26.3-x86_64.zip"

    BeforeEach {
        Initialize-TestEnvironment
        $TestWorkspace = New-Workspace
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'can download an Emacs archive' {
        Mock -Module Cackledaemon Invoke-WebRequest {
            New-Item $OutFile
        }

        $Archive = New-EmacsArchive $TestDownload

        $Archive | Should -Not -Be $null
        $ArchivePath | Should -Exist
        $Archive.FullName | Should -Be $ArchivePath

        Assert-MockCalled -Module Cackledaemon `
          Invoke-WebRequest `
          -Times 1 `
          -ParameterFilter { $Uri -eq 'https:\\test_url' }
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Export-EmacsArchive {
    param(
        [Parameter(Position=0)]
        [System.IO.FileInfo]$Archive
    )

    $Workspace = Get-Workspace

    $Source = $Archive.FullName

    $Destination = Join-Path $Workspace.Installs.FullName $Archive.BaseName

    Expand-Archive -Path $Source -DestinationPath $Destination

    return Get-Item $Destination
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Export-EmacsArchive' {
    $TestWorkspace = $null
    $TestDownload = New-Download 26 3 'https:\\test_url'
    $ArchivePath = "$TestDrive\Cackledaemon\Workspace\Archives\emacs-26.3-x86_64.zip"
    $TestArchive = $null
    $InstallPath = "$TestDrive\Cackledaemon\Workspace\Installs\emacs-26.3-x86_64"

    BeforeEach {
        Initialize-TestEnvironment
        $TestWorkspace = New-Workspace
        $TestArchive = New-Item $ArchivePath
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'can extract an Emacs archive' {
        Mock -Module Cackledaemon Expand-Archive {
            New-Item -Type Directory 'TestDrive:\Cackledaemon\Workspace\Installs\emacs-26.3-x86_64' | Out-Null
        }

        $Install = Export-EmacsArchive $TestArchive

        Assert-MockCalled -Module Cackledaemon `
          Expand-Archive `
          -Times 1 `
          -ParameterFilter { $Path -eq $ArchivePath -and $DestinationPath -eq $InstallPath }

        $Install.FullName | Should -Be $InstallPath
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Update-EmacsInstall {
    param(
        [System.IO.DirectoryInfo]$Source,
        [string]$Path
    )

    if (-not $Source) {
        $Source = Get-Item -ErrorAction Stop $Path
    }

    . $CackledaemonConfigLocation

    $Backup = Join-Path $Workspace.Backups.FullName ('emacs-{0}' -f (Get-Date -Format 'o'))

    if (Test-Path $EmacsInstallLocation -ErrorAction Stop) {
        Copy-Item $EmacsInstallLocation $Backup -ErrorAction Stop
        Remove-Item $EmacsInstallLocation -ErrorAction Stop
    }

    Move-Item $Source $EmacsInstallLocation -ErrorAction Stop
    Remove-Item $Backup

    return Get-Item $EmacsInstallLocation
}

#+END_SRC
** Environment Variables
*** PATH Environment Variable
As in Linux and OSX, Windows uses a ~Path~ variable to resolve commands in cmd
and PowerShell. The ~Path~ environment variable can be set for either the
current user or system-wide. We implement the user version because it doesn't
require admin privileges and leaves this as a choice for individual users.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Set-EmacsPathEnvVariable {
    param(
        [str]$Path
    )

    $ExistingEmacs = Get-Command 'emacs.exe' -SilentlyContinue

    if ($ExistingEmacs) {
        $ExistingEmacsBinDir = Split-Path $ExistingEmacs.Source -Parent
    }

    if ($ExistingEmacsBinDir -eq $Path) {
        Write-Warning 'An unmanaged Emacs is already installed at ' +
        ('{0} - this may cause unexpected behavior. ' -f $ExistingEmacsBinDir)
    }

    $PathProperty = (Get-ItemProperty -Path 'HKCU:\Environment' -Name 'Path')
    $PathParts = $PathProperty.Path.Split(';')

    $ExistingEmacsPathPart = $PathParts | Where-Object { $_ -eq $Path }

    if ($ExistingEmacsPathPart) {
        Write-Verbose 'Emacs is already in the PATH - no changes necessary.'
    } else {
        $PathParts += $Path
        $PathProperty.Path = $PathParts -Join ';'
        Set-ItemProperty -Path 'HKCU:\Environment' -Name 'Path' $PathProperty
    }
}

#+END_SRC
*** HOME Environment Variable
Emacs generally tries to find its init files in =$HOME/.emacs.d= but Windows
doesn't have a 1:1 concept of a home directory and the environment variable is
typically not set. Emacs for historical reasons defaults to using =$Env:AppDir=,
but in practice most people want to set =$Env:HOME= to =$Env:UserProfile=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Set-HomeEnvVariable {
    Set-ItemProperty -Path 'HKCU:\Environment' -Name 'HOME' $Env:UserProfile
}

#+END_SRC
** App Paths Registry Keys
Windows, in addition to the concept of a user ~Path~, also has the concept of
[[https://docs.microsoft.com/en-us/windows/win32/shell/app-registration][app paths]]. These paths are used so that tools like the run command - and
anything using [[https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecuteexa][the ShellExecuteEx API]] - can find the associated programs.

The relevant registry entries are in ~HKEY_LOCAL_MACHINE~ and need to be set
as an administrator.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Set-EmacsAppPathRegistryKeys {
    param(
        [string]$Path
    )

    @('emacs.exe', 'runemacs.exe', 'emacsclient.exe', 'emacsclientw.exe') | ForEach-Object {
        $RegistryPath = Join-Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths' $_
        $BinPath = Join-Path $Path $_

        if (Test-Path $BinPath) {
            Set-Item -Path $RegistryPath -Value $BinPath
            Set-ItemProperty -Path $RegistryPath -Name Path -Value $Path
        } else {
            Write-Error -Message ("{0} doesn't exist - refusing to write this to the registry." -f $BinPath) `
              -Category ObjectNotFound `
              -CategoryActivity 'Set-EmacsAppPathRegistryKeys' `
              -CategoryReason 'ItemNotFoundException'`
              -CategoryTargetName $BinPath `
              -CategoryTargetType 'string'
        }

    }
}

#+END_SRC
** Start Menu and Shortcuts
*** Start Menu Items
Emacs's ~addpm.exe~ creates a shortcut to ~emacs.exe~ in a sub-folder called
"Gnu Emacs". The default Start menu path follows this convention.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Get-StartMenuItems {
    . $CackledaemonConfigLocation
    Get-ChildItem -Path $StartMenuPath
}

#+END_SRC
*** Creating Shortcuts
We can create a shortcut by using [[https://docs.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal][COM]] to interact with [[https://en.wikipedia.org/wiki/Windows_Script_Host][Windows Script Host.]]

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Get-WShell {
    if (-not $WShell) {
        $Global:WShell = New-Object -comObject WScript.Shell
    }

    return $WShell
}

function Set-Shortcut {
    param(
        [string]$ShortcutPath,
        [string]$TargetPath,
        [string[]]$Argumentlist = @(),
        [string]$WorkingDirectory = $Env:USERPROFILE,
        [string]$Description
    )

    $Shell = Get-WShell

    $Shortcut = $Shell.CreateShortcut($ShortcutPath)
    $Shortcut.TargetPath = $TargetPath
    $Shortcut.Arguments = $ArgumentList
    $Shortcut.WorkingDirectory = $WorkingDirectory
   
    if ($Description) {
        $Shortcut.Description = $Description
    }

    $Shortcut.Save()
}

#+END_SRC
*** Installation
Given a shortcuts config, we can "install" them by comparing the shortcuts in
the directory with the ones that are configured, cleaning up the ones we don't
want and setting the rest.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Install-Shortcuts {
    $Config = Get-ShortcutsConfig
    $CurrentItems = Get-StartMenuItems
    $DesiredShortcutNames = $Config | ForEach-Object { $_.ShortcutName }

    $CurrentItems | ForEach-Object {
        Split-Path $_ -Leaf
    } | Where-Object {
        -not $DesiredFilenames.Contains($_)
    } | ForEach-Object {
        Remove-Item $_
    }

    $Config | ForEach-Object {
        Set-Shortcut `
          -ShortcutPath (Join-Path $StartMenuPath $_.ShortcutName) `
          -TargetPath (Join-Path $EmacsInstallLocation $_.EmacsBinaryName) `
          -ArgumentList $_.ArgumentList `
          -Description $_.Description
    }
}

#+END_SRC
** File Type Associations
File type associations in Windows are [[https://twitter.com/jfhbrook/status/1245917952316039169]["complicated"]] and the documentation for
them isn't great.

At the user level, Explorer manages a bunch of registry settings that encode
which applications a user has associated with a file type via the "Open With"
dialogs, as well as what they've picked as the default for opening that file.
The structure of these registry settings is complicated and research has
indicated that Microsoft would just as soon not have programs messing with these
settings.

However, on the system level, the batch commands [[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/ftype][ftype]] and [[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/assoc][assoc]] can be used to
set file type associations. These associations can be used to set defaults for
Explore for when a user hasn't interacted with them. ~assoc~ associates an
extension with a human-readable file type, and ~ftype~ connects that file type
with a command template.

This means that while the config for this is managed in
a single table, Windows actually manages these in two separate collections - one
for each command. The upshot is that it's possible to have a file type
registered with ~assoc~ but not in ~ftype~, and vice versa. In practice,
however, having one of these fields as null isn't very useful, so we don't
support it.

Additionally, while both of these commands support unsetting a key, we never
attempt to do any cleanup since it's assumed that an unused association is
non-harmful, while removing a used association on accident is very bad.

Note that these commands must be ran with Administrator privileges.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Install-FileTypeAssociations {
    Get-FileTypeAssociationsConfig | ForEach-Object {
        cmd /c assoc ("{0}={1}" -f $_.Extension, $_.FileType)
        cmd /c ftype ("{0}={1}" -f $_.FileType, $_.Command)
    }
}

#+END_SRC
** Putting It All Together
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Install-Emacs {
    if (Test-EmacsExe) {
        Write-Host "Emacs is already installed. To update Emacs, run Update-Emacs."
        return
    }

    . $CackledaemonConfigLocation

    if (Test-Workspace) {
        $Workspace = Get-Workspace
    } else {
        $Workspace = New-Workspace
    }

    $TargetVersion = Get-LatestEmacsDownload

    if ($Workspace.TestInstall($TargetVersion)) {
        $Install = $Workspace.GetInstall($TargetVersion)
    } else {
        if ($Workspace.TestArchive($TargetVersion)) {
            $Archive = $Workspace.GetArchive($TargetVersion);
        } else {
            $Archive = New-EmacsArchive $TargetVersion
        }

        $Install = Export-EmacsArchive $Archive
    }

    Start-Process -Wait powershell.exe -Verb RunAs -ArgumentList '-Command' "{
        Import-Module Cackledaemon
        Update-EmacsInstall -Path $Install
        Set-EmacsAppPathRegistryKeys
        Install-FileTypeAssociations
    }"

    Set-EmacsPathEnvVariable
    Set-HomeEnvVariable

    Install-Shortcuts
}

#+END_SRC
* Daemon Management
** TCP Server File
Typically ~emacsclient~ communicates with the daemon using unix sockets, but
Windows doesn't support them. Therefore, Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/TCP-Emacs-server.html][runs its server over TCP]] and
~emacsclient.exe~ looks for a file that advertises the port. This file by
default needs to exist in =~/.emacs.d/server/=. If the =~/.emacs.d= folder
doesn't exist for whichever reason - for instance if you're using a =~/.emacs=
file and don't have a =~/.emacs.d=, which is possible if you're using [[https://github.com/plexus/chemacs][Chemacs]] -
then the Emacs daemon will fail to create that file and ~emacsclient.exe~ will
be unable to connect.

Working around this involves setting a variable inside your Emacs config, but
generally speaking you should just ensure that =~/.emacs.d= exists where it's
expected.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
$DefaultServerFileDirectory = Join-Path $Env:UserProfile '.emacs.d/server'

function Get-ServerFileDirectory {
    [CmdletBinding()]
    param(
        [string]$Path = $DefaultServerFileDirectory
    )

    Get-Item $Path
}

function Test-ServerFileDirectory {
    [CmdletBinding()]
    param(
        [string]$Path = $DefaultServerFileDirectory
    )

    Test-Item $Path
}

function New-ServerFileDirectory {
    [CmdletBinding()]
    param(
        [string]$Path = $DefaultServerFileDirectory
    )

    New-Item $Path
}

function Clear-ServerFileDirectory {
    [CmdletBinding()]
    param(
        [string]$Path = $DefaultServerFileDirectory
    )

    Get-ChildItem $Path | ForEach-Object {
        Remove-Item $_
    }
}

#+END_SRC
** Process State Serialization
In order to do basic monitoring of the Emacs daemon, we serialize the process
object to and from a JSON file inside the working directory. We only need to
save the ID, but storing the entire process object is easier.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

$PidFile = Join-Path $CackledaemonWD 'DaemonPidFile.json'

function Write-EmacsProcessToPidFile {
    param([System.Diagnostics.Process]$Process)

    ($Process).Id | ConvertTo-Json | Out-File $PidFile
}

function Get-EmacsProcessFromPidFile {
    if (-not (Test-Path $PidFile)) {
        return $null
    }

    $Id = (Get-Content $PidFile | ConvertFrom-Json)

    if (-not $Id) {
        Remove-Item $PidFile
        return $null
    }

    return Get-Process -Id $Id -ErrorAction SilentlyContinue
}

#+END_SRC
** Checking For Existing Daemons
It would probably be bad to try to start an Emacs daemon if one is already
running.

if an Emacs daemon is being managed, then retrieving the process state should be
successful and we can simply check to make sure that =Get-EmacsProcessFromPidFile=
returns a non-=$null= value. However, it's also possible to start the Emacs
daemon out-of-band, in which case we probably don't want to get involved either.
To check for this, we use [[https://docs.microsoft.com/en-us/powershell/module/cimcmdlets/get-ciminstance?view=powershell-7][CIM]] to find emacs processes and then check to see if
any of them have ~--daemon~ in their command line args. We intentionally punt on
the edge case of searching for emacs instances *not* started with the ~--daemon~
but which have called =(run-server)=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Get-UnmanagedEmacsDaemons () {
    $ManagedProcess = $(Get-EmacsProcessFromPidFile)
    return Get-CimInstance -Query "
        SELECT
          ,*
        FROM Win32_Process
        WHERE
          Name = 'emacs.exe' OR Name = 'runemacs.exe'
    " | Where-Object {
        $_.CommandLine.Contains("--daemon")
    } | ForEach-Object {
        Get-Process -Id ($_.ProcessId)
    } | Where-Object { -not ($_.Id -eq $ManagedProcess.Id) }
}

#+END_SRC
** Start the Emacs Daemon
This function launches the Emacs daemon (if it's not running already) with
sensible parameters and stores process info so we can do basic monitoring.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Start-EmacsDaemon {
    [CmdletBinding()]
    param ([switch]$Wait)

    . $CackledaemonConfigLocation

    $Process = $(Get-EmacsProcessFromPidFile)

    if ($Process) {
        Write-LogError `
          -Message 'The Emacs daemon is already running and being managed.' `
          -Category ResourceExists `
          -CategoryActivity 'Start-EmacsDaemon' `
          -CategoryReason ManagedResourceExistsException

    } elseif ($(Get-UnmanagedEmacsDaemons)) {
        Write-LogError `
          -Message 'An unmanaged Emacs daemon is running.' `
          -Category ResourceExists `
          -CategoryActivity 'Start-EmacsDaemon' `
          -CategoryReason UnmanagedResourceExistsException
    } else {
        Write-LogVerbose 'Starting the Emacs daemon...'

        $Process = Start-Process `
          -FilePath 'emacs.exe' `
          -ArgumentList '--daemon' `
          -NoNewWindow `
          -RedirectStandardOut $EmacsStdOutLogFile `
          -RedirectStandardError $EmacsStdErrLogFile `
          -PassThru

        Write-EmacsProcessToPidFile $Process

        if ($Wait) {
            Write-Verbose 'Waiting for Emacs daemon to exit...'
            $Process = Wait-Process -InputObject $Process
        }

        Write-Verbose 'Done.'

        return $Process
    }
}

#+END_SRC
** Get the Emacs Daemon
We actually already have this, its name just isn't very ergonomic. We'll set it
as an alias here for convenience.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Get-EmacsDaemon {
    [CmdletBinding()]
    param()

    Get-EmacsProcessFromPidFile
}

#+END_SRC
** Stop the Emacs Daemon
Stopping the process is simply a matter of retrieving the process state from
disk and attempting to stop the process.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Stop-EmacsDaemon {
    [CmdletBinding()]
    param()

    $Process = Get-EmacsProcessFromPidFile

    if (-not $Process) {
        Write-LogError `
          -Message "A managed Emacs daemon isn't running and can not be stopped!" `
          -Category ResourceUnavailable `
          -CategoryActivity 'Stop-EmacsDaemon' `
          -CategoryReason ManagedResourceUnavailableException
    } else {
        Write-LogVerbose 'Stopping the Emacs daemon...'

        Stop-Process -InputObject $Process

        Write-EmacsProcessToPidFile $null

        Write-LogVerbose 'Done.'
    }
}

#+END_SRC
** Restart the Emacs Daemon
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Restart-EmacsDaemon {
    [CmdletBinding()]
    param()

    try {
        Stop-EmacsDaemon -ErrorAction Stop
    } catch {
        Write-LogWarning $_.Exception.Message
    }

    Start-EmacsDaemon
}

#+END_SRC
* Desktop Applet
Cackledaemon uses Windows Forms to create a desktop tray applet.

Note that there are a few things that may seem a little odd but are necessary:

- Using global variables. This is because code running outside of this
  function's scope, including certain kinds of callbacks, need access to these
  properties.
- Creating and showing a Form even though nothing is being drawn to it. If the
  form doesn't exist when we try to generate the context menu, very strange
  things happen.

The vast majority of menu items launch a separate PowerShell instance which then
imports Cackledaemon and attempts to run the appropriate function. As such, the
module needs to be properly installed in PowerShell's module search paths in
order for this applet to function properly.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
Add-Type -AssemblyName System.Windows.Forms

function Invoke-Applet {
    [CmdletBinding()]
    param()

    # The parent Form

    $Global:AppletForm = New-Object System.Windows.Forms.Form
    $AppletForm.Visible = $False
    $AppletForm.WindowState = "minimized"
    $AppletForm.ShowInTaskbar = $False

    # The NotifyIcon

    $Global:AppletIcon = New-Object System.Windows.Forms.NotifyIcon
    $AppletIcon.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon(
        (Get-Command 'emacs.exe').Path
    )
    $AppletIcon.Visible = $True

    # Notify the user if something fails

    function Start-InstrumentedBlock {
        param(
            [Parameter(Position=0)]
            [string]$Message,

            [Parameter(Position=1)]
            [ScriptBlock]$ScriptBlock,

            [System.Windows.Forms.ToolTipIcon]$Icon = [System.Windows.Forms.ToolTipIcon]::Warning
        )

        try {
            Invoke-Command -ScriptBlock $ScriptBlock
        } catch {
            Try {
                . $CackledaemonConfigLocation
            } Catch {
                Write-Warning 'Unable to load configuration! Using default notify timeout.'
                $NotifyTimeout = 5000
            }

            Write-LogError -Message $_.Exception.Message `
              -Exception $_.Exception `
              -Category $_.CategoryInfo.Category `
              -CategoryActivity $_.CategoryInfo.Activity `
              -CategoryReason $_.CategoryInfo.Reason `
              -CategoryTargetName $_.CategoryInfo.TargetName `
              -CategoryTargetType $_.CategoryInfo.TargetType

            $AppletIcon.BalloonTipIcon = $Icon
            $AppletIcon.BalloonTipTitle = $Message
            $AppletIcon.BalloonTipText = $_.Exception
            $AppletIcon.ShowBalloonTip($NotifyTimeout)
        }

    }

    # The right-click menu

    $ContextMenu = New-Object System.Windows.Forms.ContextMenu
    $AppletIcon.ContextMenu = $ContextMenu

    # Status items

    $DaemonStatusItem = New-Object System.Windows.Forms.MenuItem
    $DaemonStatusItem.Index = 0
    $DaemonStatusItem.Text = '[???] Emacs Daemon'
    $ContextMenu.MenuItems.Add($DaemonStatusItem) | Out-Null

    $LogRotateStatusItem = New-Object System.Windows.Forms.MenuItem
    $LogRotateStatusItem.Text = '[???] Emacs Logs Rotation'
    $ContextMenu.MenuItems.Add($LogRotateStatusItem) | Out-Null

    $AppletIcon.add_MouseDown({
        $Process = Get-EmacsProcessFromPidFile
        if ($Process) {
            $DaemonStatusItem.Text = '[RUNNING] Emacs Daemon'
            $StartDaemonItem.Enabled = $False
            $StopDaemonItem.Enabled = $True
            $RestartDaemonItem.Enabled = $True
        } else {
            $DaemonStatusItem.Text = '[STOPPED] Emacs Daemon'
            $StartDaemonItem.Enabled = $True
            $StopDaemonItem.Enabled = $False
            $RestartDaemonItem.Enabled = $True
        }

        $Job = Get-Job -Name 'LogRotateJob' -ErrorAction SilentlyContinue

        if ($Job) {
            $State = $Job.State.ToUpper()

            if ($State -eq 'RUNNING') {
                $State = 'ENABLED'
            }

            $LogRotateStatusItem.Text = ('[{0}] Logs Rotation' -f $State)
            $EnableLogRotateJobItem.Enabled = $False
            $DisableLogRotateJobItem.Enabled = $True
        } else {
            $LogRotateStatusItem.Text = '[DISABLED] Logs Rotation'
            $EnableLogRotateJobItem.Enabled = $True
            $DisableLogRotateJobItem.Enabled = $False
        }
    })

    $ContextMenu.MenuItems.Add('-') | Out-Null

    # Daemon lifecycle items

    $StartDaemonItem = New-Object System.Windows.Forms.MenuItem
    $StartDaemonItem.Text = 'Start Emacs Daemon...'
    $StartDaemonItem.add_Click({
        Start-InstrumentedBlock 'Failed to start the Emacs daemon' {
            Start-EmacsDaemon -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($StartDaemonItem) | Out-Null

    $StopDaemonItem = New-Object System.Windows.Forms.MenuItem
    $StopDaemonItem.Text = 'Stop Emacs Daemon...'
    $StopDaemonItem.add_Click({
        Start-InstrumentedBlock 'Failed to stop the Emacs daemon' {
            Stop-EmacsDaemon -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($StopDaemonItem) | Out-Null

    $RestartDaemonItem = New-Object System.Windows.Forms.MenuItem
    $RestartDaemonItem.Text = 'Restart Emacs Daemon...'
    $RestartDaemonItem.add_Click({
        Start-InstrumentedBlock 'Failed to restart the Emacs daemon' {
            Restart-EmacsDaemon -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($RestartDaemonItem) | Out-Null

    $ContextMenu.MenuItems.Add('-') | Out-Null

    # Log rotate items

    $EnableLogRotateJobItem = New-Object System.Windows.Forms.MenuItem
    $EnableLogRotateJobItem.Text = 'Enable Log Rotation...'
    $EnableLogRotateJobItem.add_Click({
        Start-InstrumentedBlock 'Failed to enable log rotation' {
            Enable-LogRotateJob -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($EnableLogRotateJobItem) | Out-Null

    $DisableLogRotateJobItem = New-Object System.Windows.Forms.MenuItem
    $DisableLogRotateJobItem.Text = 'Disable Log Rotation...'
    $DisableLogRotateJobItem.add_Click({
        Start-InstrumentedBlock 'Failed to disable log rotation' {
            Disable-LogRotateJob -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($DisableLogRotateJobItem) | Out-Null

    $ContextMenu.MenuItems.Add('-') | Out-Null

    $EditConfigItem = New-Object System.Windows.Forms.MenuItem
    $EditConfigItem.Text = 'Edit Configuration...'
    $EditConfigItem.add_Click({
        Start-InstrumentedBlock 'Failed to edit configuration' {
            Start-Process $CackledaemonConfigLocation
        }
    })
    $ContextMenu.MenuItems.Add($EditConfigItem) | Out-Null

    $OpenWDItem = New-Object System.Windows.Forms.MenuItem
    $OpenWDItem.Text = 'Open Working Directory...'
    $OpenWDItem.add_Click({
        Start-InstrumentedBlock 'Failed to open working directory' {
            Start-Process $CackledaemonWD -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($OpenWDItem) | Out-Null

    $ContextMenu.MenuItems.Add('-') | Out-Null

    $ExitItem = New-Object System.Windows.Forms.MenuItem
    $ExitItem.Text = 'Exit'
    $ContextMenu.MenuItems.Add($ExitItem) | Out-Null

    # Lifecycle events

    $AppletForm.add_Load({
        Start-InstrumentedBlock 'Failed to start the Emacs daemon' {
            Start-EmacsDaemon -ErrorAction Stop
        }
        Start-InstrumentedBlock 'Failed to enable log rotation' {
            Enable-LogRotateJob -ErrorAction Stop
        }
    })

    $ExitItem.add_Click({
        if (Get-EmacsDaemon) {
            Start-InstrumentedBlock 'Failed to gracefully shut down Emacs' {
                Stop-EmacsDaemon -ErrorAction Stop
            }
        }

        if (Get-Job -Name 'LogRotateJob' -ErrorAction SilentlyContinue) {
            Start-InstrumentedBlock 'Failed to gracefully shut down log rotation' {
                Disable-LogRotateJob -ErrorAction Stop
            }
        }
        $AppletIcon.Visible = $False
        $AppletIcon.Dispose()
        $AppletForm.Close()
        Remove-Variable -Name AppletForm -Scope Global
        Remove-Variable -Name AppletIcon -Scope Global
    })


    $AppletForm.ShowDialog() | Out-Null
}

#+END_SRC

* Exports
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
Export-ModuleMember `
  -Function @(
      'New-CackledaemonWD',
      'Get-FileTypeAssociationsConfig',

      'New-Version',
      'New-Download',

      'Write-Log',
      'Write-LogDebug',
      'Write-LogInformation',
      'Write-LogVerbose',
      'Write-LogWarning',
      'Write-LogError',

      'Enable-CackledaemonJob',
      'Disable-CackledaemonJob',

      'Get-Workspace',
      'New-Workspace',
      'Remove-Workspace',

      'Get-EmacsExeVersion',
      'Get-EmacsDownload',
      'Get-LatestEmacsDownload',

      'New-EmacsArchive',
      'Export-EmacsArchive'

      'Set-EmacsAppPathRegistryKeys',
      'Set-EmacsPathEnvVariable',
      'Set-HomeEnvVariable',

      'Get-StartMenuPath',
      'New-Shortcut',
      'Get-ShortcutsConfig',

      # filetype stuff

      'Invoke-LogRotate',
      'Enable-LogRotateJob',
      'Disable-LogRotateJob',

      'Start-EmacsDaemon',
      'Get-EmacsDaemon',
      'Stop-EmacsDaemon',
      'Restart-EmacsDaemon',
      'Get-UnmanagedEmacsDaemons',

      'Invoke-Applet',
      'Test-EmacsExe'
  )`
  -Variable @(
      'CackledaemonWD',
      'CackledaemonConfigLocation'
  )

#+END_SRC
* Manifest
https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psd1
@{
    RootModule = 'Cackledaemon.psm1'

    ModuleVersion = '0.0.14'
    GUID = '10d14360-ee5c-4363-bfe8-f4116a8ce764'

    Author = 'Josh Holbrook'
    Copyright = 'Copyright 2020 Josh Holbrook.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.'

    Description = 'An Emacs installation and runtime manager for Windows'

    # Modules that must be imported into the global environment prior to importing this module
    # RequiredModules = @()

    # Assemblies that must be loaded prior to importing this module
    RequiredAssemblies = @('System.Windows.Forms')

    # Script files (.ps1) that are run in the caller's environment prior to importing this module.
    # ScriptsToProcess = @()

    # Modules to import as nested modules of the module specified in RootModule/ModuleToProcess
    # NestedModules = @()

    FunctionsToExport = @(
        'New-CackledaemonWD',
        'Invoke-LogRotate',
        'Enable-LogRotateJob',
        'Disable-LogRotateJob',
        'Start-EmacsDaemon',
        'Get-EmacsDaemon',
        'Stop-EmacsDaemon',
        'Restart-EmacsDaemon',
        'Get-UnmanagedEmacsDaemons',
        'Invoke-Applet'
    )

    CmdletsToExport = @()
    VariablesToExport = @(
        'CackledaemonWD',
        'CackledaemonConfigLocation'
    )

    FileList = @(
        'Cackledaemon.psm1',
        'Cackledaemon.psd1',
        'DefaultConfiguration.ps1',
        'COPYING'
    )
    ModuleList = @('.\Cackledaemon.psm1')

    PrivateData = @{
        PSData = @{
            Tags = @('emacs')
            LicenseUri = 'https://github.com/jfhbrook/cackledaemon/blob/master/COPYING'
            ProjectUri = 'https://github.com/jfhbrook/cackledaemon'

            # A URL to an icon representing this module.
            # IconUri = ''

            # ReleaseNotes of this module
            # ReleaseNotes = ''
        }
    }

    # HelpInfo URI of this module
    # https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-create-a-helpinfo-xml-file?view=powershell-7
    # HelpInfoURI = ''

    # Default prefix for commands exported from this module. Override the default prefix using Import-Module -Prefix.
    # DefaultCommandPrefix = ''

}

#+END_SRC
* Development Tasks
Cackledaemon can be built and published using [[https://github.com/nightroman/Invoke-Build][Invoke-Build]].

#+BEGIN_SRC powershell :tangle Cackledaemon.Build.ps1
task . Clean, Build, Test

#+END_SRC
** Building Cackledaemon
=Invoke-Build= will call Emacs in batch mode to build this project using
~org-babel~. Alternately, you may type ~C-c C-v t~ with this file open in Emacs.

This emacs batch script tangles ~cackledaemon.org~ and generates the ~README.md~:

#+BEGIN_SRC emacs-lisp :tangle build.el
(progn
  (require 'org)
  (require 'ob-tangle)
  (require 'ox-md)

  (with-current-buffer (find-file-noselect "cackledaemon.org")
    (message "Tangling Code...")
    (org-babel-tangle)
    (message "Generating README...")
    (org-export-to-file 'md "README.md"))
  (message "Done."))
#+END_SRC

=Invoke-Build= wraps this in a task which shells out to Emacs:

#+BEGIN_SRC powershell :tangle Cackledaemon.Build.ps1
task Build {
    emacs.exe --batch --load build.el
    Remove-Item 'README.md~' -ErrorAction 'SilentlyContinue'
}

#+END_SRC

** Cleanup
#+BEGIN_SRC powershell :tangle Cackledaemon.Build.ps1
task Clean {
    Get-ChildItem './Cackledaemon' | ForEach-Object {
        Remove-Item $_.FullName
    }
    Remove-Item 'README.md' -ErrorAction 'SilentlyContinue'
    Remove-Item 'README.md~' -ErrorAction 'SilentlyContinue'
}

#+END_SRC
** Testing Cackledaemon
#+BEGIN_SRC powershell :tangle Cackledaemon.Build.ps1
task Test {
    powershell -Command Invoke-Pester
}

#+END_SRC
** Publishing Cackledaemon
This project can be published on the Powershell Gallery by running
=Invoke-Build Publish.= In order for it to succeed, there must be a
=.\Secrets.ps1= file that defines =$PowershellGalleryAPIKey= as a valid
Powershell Gallery NuGet API key. This file gets sourced by the ~Publish~ task.

#+BEGIN_SRC powershell :tangle Cackledaemon.Build.ps1
task Publish Build, {
    . .\Secrets.ps1
     Publish-Module -Path .\Cackledaemon\ -NuGetApiKey $PowershellGalleryAPIKey
}
#+END_SRC

* License :export:
Cackledaemon, much like Emacs, is licensed under the terms of the GPL v3 or
newer.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
# Copyright 2020 Josh Holbrook
#
# This file is part of Cackledaemon and not a part of Emacs.
#
# Cackledaemon is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Cackledaemon is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cackledaemon.  if not, see <https://www.gnu.org/licenses/>.


#+END_SRC
