#+TITLE: Cackledaemon - An Emacs Daemon Manager for Windows
#+AUTHOR: Josh Holbrook
#+OPTIONS: tags:nil


* Introduction :export:
#+BEGIN_QUOTE
Oh-ho-ho! Swirly Photoshop magic! I bet this thing could release some serious
cackledemons!

-- Strong Bad
#+END_QUOTE

Anyone who has used a fully configured [[https://www.gnu.org/software/emacs/][Emacs]] install such as [[https://www.spacemacs.org/][Spacemacs]] or [[https://github.com/hlissner/doom-emacs][Doom]]
knows that Emacs can take a long time to initially boot. This isn't for a lack
of trying - in fact, the source code for Doom is half speed hacks and I highly
encourage anybody hacking on Emacs to take a look.

The truth is that Emacs is less a code editor and more of a *framework* for
*writing text-based applications*. I like to compare it to [[https://nodejs.org][Node.js]] in this
regard, which, while really good at being a webserver is no [[https://www.nginx.com/][NGINX]], but instead a
runtime where you can import lots of tiny pieces of functionality a la carte to
make your own webserver. Any one of these configurations does exactly this - it
installs packages from the internet, requires them and uses [[https://www.gnu.org/software/emacs/manual/html_node/eintr/][Emacs Lisp]] to create
a complete application. Spacemacs and Doom are built similarly, but feel
different because they *are* in fact meaningfully different.

Just as you don't want to load the JavaScript runtime for every request (this is
how non-Node webservers [[https://en.wikipedia.org/wiki/Common_Gateway_Interface][used to do in the olden days]] and trust me it was not
very good) you don't really want to load all of Emacs every time you open a file
either. It's less than ideal.

Luckily for us, Emacs can be ran [[https://www.emacswiki.org/emacs/EmacsAsDaemon][as a daemon]] and connected to via a client,
typically ~emacsclient~. In Linux and [[https://www.freedesktop.org/wiki/Software/systemd/][systemd]] this works seamlessly - often you
can run =systemctl start --user emacs= and be off to the races. In OSX it's only
a little harder - you [[https://www.emacswiki.org/emacs/EmacsAsDaemon#toc8][copy-paste a plist file from the wiki]], pull some very
minor shenanigans and have a mostly working daemon.

In Windows it's a bit more of a mess. This is because the Windows abstractions
for processes and services are wildly divergent from those in nix-like
environments such as Linux and OSX. Init systems like systemd run and manage
normal process, meanwhile in Windows services are in fact [[https://docs.microsoft.com/en-us/dotnet/framework/windows-services/walkthrough-creating-a-windows-service-application-in-the-component-designer][special programs]] that
[[https://docs.microsoft.com/en-us/dotnet/api/system.serviceprocess?view=netframework-4.8][expose an alternate interface]] to that of the standard process. The upshot is
that any standard process that one wants to run as a Windows service needs to be
wrapped in one of these special programs, complete with bespoke abstractions for
process management, log management and so on.

Alternately, arbitrary processes may be [[https://support.microsoft.com/en-us/help/4026268/windows-10-change-startup-apps][configured to start on user login]].
Practically speaking, this is how most persistent applications are ran in
Windows, and in fact the [[https://www.emacswiki.org/emacs/EmacsMsWindowsIntegration#toc8][approach documented in the wiki]] does exactly this - it
uses a Powershell script to generate a very simple [[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands][batch file]] that cleans up
server state from the prior run and then spawns the Emacs daemon.

This works OK. However, there are some downsides. If the Emacs daemon crashes
for any reason, there's no signal other than ~emacsclient~ mysteriously not
working; any logs that come out of the Emacs daemon are lost to the aether; and
straightforward lifecycle actions that can be done casually with systemd (start,
top, restart, status) are very non-ergonomic.

Luckily, [[https://docs.microsoft.com/en-us/powershell/scripting/overview][PowerShell]] has our back. PowerShell is a shockingly good language - it
performs admirably as a shell and yet scales to general purpose use, even being
capable of making proper [[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes][.NET classes]]. More to the point, it's very good at
[[https://docs.microsoft.com/en-us/powershell/scripting/samples/managing-processes-with-process-cmdlets][managing processes]] and has [[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/background-jobs][special support for background jobs]], as well as being
able to [[https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.notifyicon][instantiate and manage tray icons]] via [[https://docs.microsoft.com/en-us/dotnet/framework/winforms/][Windows Forms]]. All it needs is a
little elbow grease!

Cackledaemon is a PowerShell module that intends to be a solution for managing
such an instance of the Emacs daemon for Windows. It includes functions for
starting, stopping and restarting the Emacs daemon, functions and jobs for log
management and rotation, and a tray icon for a lil' point-and-click action and
notifications for if/when Emacs exits unexpectedly.

* Exceptions
Cackledaemon uses custom exceptions to signal states during lifecycle actions
that it doesn't know how to handle. Note that PowerShell doesn't allow for
exporting classes; you'll need to use duck typing.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

class CackledaemonException: System.Exception {
    [string]$Type
   
    CackledaemonException([string]$Message): base($Message) {}
}

class LogRotateAlreadyRunningException: CackledaemonException {
    LogRotateAlreadyRunningException([string]$Message) : base($Message) {
        $this.Type = 'LOG_ROTATE_ALREADY_RUNNING'
    }
}

class LogRotateNotRunningException: CackledaemonException {
    LogRotateNotRunningException([string]$Message) : base($Message) {
        $this.Type = 'LOG_ROTATE_NOT_RUNNING'
    }
}

class EmacsAlreadyRunningException: CackledaemonException {
    EmacsAlreadyRunningException([string]$Message) : base($Message) {
        $this.Type = 'EMACS_ALREADY_RUNNING'
    }
}

class EmacsNotRunningException: CackledaemonException {
    EmacsNotRunningException([string]$Message) : base($Message) {
        $this.Type = 'EMACS_NOT_RUNNING'
    }
}

#+END_SRC
* Working Directory
Cackledaemon needs a place to store logs and process metadata. For this purpose,
we use a folder inside =APPDATA=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

$CackledaemonWD = Join-Path $env:APPDATA 'cackledaemon'

function Invoke-EnsureCackledaemonWD {
    If (-not (Test-Path $CackledaemonWD)) {
        New-Item -Path $CackledaemonWD -ItemType directory
    }
}

#+END_SRC

* Logging
** Settings
These are the settings for log location and rotation.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

$CackledaemonLogFile = Join-Path $CackledaemonWD 'Cackledaemon.log'
$EmacsStdOutLogFile = Join-Path $CackledaemonWD 'EmacsStdout.log'
$EmacsStdErrLogFile = Join-Path $CackledaemonWD 'EmacsStderr.log'
$LogSize = 1mb
$LogRotate = 4
$LogCheckTime = 2  # Seconds

#+END_SRC
** Logger
Cackledaemon's logger is dirt dirt simple. It doesn't have any log levels - it
simply writes a message to the log file formatted with a greppable tag and a
timestamp.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Write-CackledaemonLog {
    Param ([string]$Message)

    Invoke-EnsureCackledaemonWD

    $Line = ('[{0}] CACKLEDAEMON: {1}' -f (Get-Date -Format o), $Message)

    Add-Content $CackledaemonLogFile -value $Line
}

#+END_SRC
** Log Rotation
For log rotation, we use a PowerShell job. It more or less tries to emulate a
typical logrotate config - it rotates the log if it's at or over a certain size,
retains some finite count of log files, and drops the last one if necessary. It
will do this every configured amount of seconds indefinitely.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Get-CackledaemonLogRotateJob {
    Get-Job -Name 'CackledaemonLogRotateJob' -ErrorAction SilentlyContinue
}

function Start-CackledaemonLogRotateJob {
    Invoke-EnsureCackledaemonWD

    If (Get-CackledaemonLogRotateJob | Where-Object { $_.State -eq 'Running' }) {
        throw [CackledaemonLogRotateNotRunningException]::new(
            "The Cackledaemon logrotate job is already running!"
        )
    }

    Start-Job `
    -Name 'CackledaemonLogRotateJob' `
    -InitializationScript {
        Import-Module Cackledaemon
    } `
    -ScriptBlock {
        Set-Location $CackledaemonWD

        while ($true) {
            @($CackledaemonLogFile, $EmacsStdoutLogFile, $EmacsStdErrLogFile) | ForEach-Object {
                $LogFile = $_

                If ((Get-Item $LogFile).Length -ge $LogSize) {
                    Write-CackledaemonLog ('Rotating {0}...' -f $LogFile)

                    ($LogRotate..0) | ForEach-Object {
                        $Current = $(If ($_) {
                          '{0}.{1}' -f $LogFile, $_
                        } Else { $LogFile })

                        $Next = '{0}.{1}' -f $LogFile, ($_ + 1)

                        If (Test-Path $Current) {
                            Write-CackledaemonLog ('Copying {0} to {1}...' -f $Current, $Next)

                            Copy-Item -Path $Current -Destination $Next
                        }
                    }

                    Write-CackledaemonLog ('Truncating {0}...' -f $LogFile)

                    Clear-Content $LogFile

                    $StaleLogFile = '{0}.{1}' -f ($LogRotate + 1)

                    If (Test-Path $StaleLogFile) {
                        Write-CackledaemonLog ('Removing {0}...' -f $StaleLogFile)

                        Remove-Item $StaleLogFile
                    }

                    Write-CackledaemonLog 'Done.'
                }
            }
            Write-CackledaemonLog 'All quiet on the Western front...'
            Start-Sleep -Seconds $LogCheckTime
        }
    }
}

function Stop-CackledaemonLogRotateJob {
    Stop-Job -Name 'CackledaemonLogRotateJob'
}

function Remove-CackledaemonLogRotateJob {
    Remove-Job -Name 'CackledaemonLogRotateJob'
}

#+END_SRC
* Notifications
Cackledaemon sparingly uses balloon tips for simple notifications.

The overall strategy is lifted from [[https://mcpmag.com/articles/2017/09/07/creating-a-balloon-tip-notification-using-powershell.aspx][this article]] but wrapped in a class.

It's currently broken because the example depends on clicking the icon that this
creates in the systray, but I want to do the cleanup for when I merely close the
notification. This will take more work and be an entire goat rope.

#+BEGIN_SRC powershell

# It's actually appropriate for the icon to be global, because it's actually
# 1:1 with the icon in the systray, not the notification itself. We should
# instead refactor this to be a persisted global variable icon like in the
# example article. It will probably not be necessary to wrap it in a class.

class NotificationManager : IDisposable {
    [System.Windows.Forms.NotifyIcon]$NotifyIcon
    [Int32]$Timeout

    Notification([string]$Hed, [string]$Dek, [Int32]$Timeout) {
        $this.InitializeIcon($Hed, $Dek)
        $this.Timeout = $Timeout
    }

    Notification([string]$Hed, [string]$Dek) {
        $this.InitializeIcon($Hed, $Dek)
        $this.Timeout = 5000
    }

    InitializeIcon([string]$Hed, [string]$Dek) {
        $this.NotifyIcon = New-Object System.Windows.Forms.NotifyIcon
        $this.NotifyIcon.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon(
            (Get-Command 'emacs.exe').Path
        )
        $this.NotifyIcon.BalloonTipIcon = [System.Windows.Forms.ToolTipIcon]::Warning
        $this.NotifyIcon.BalloonTipTitle = $Hed
        $this.NotifyIcon.BalloonTipText = $Dek
        $this.NotifyIcon.Visible = $true
    }

    Show() {
        $SourceId = ("CackledaemonBalloonTipClosedJob{0}" -f ((New-Guid).Guid))

        Register-ObjectEvent -InputObject $this.NotifyIcon -EventName MouseDoubleClick -SourceIdentifier $SourceId -Action {
            Unregister-Event -SourceIdentifier $SourceId
            Remove-Job -Name $SourceId
            $this.Dispose()
        }

        $this.NotifyIcon.ShowBalloonTip($this.Timeout)
    }

    Dispose() {
        $this.NotifyIcon.Dispose()
    }
}

$Notify = [Notification]::new("hed", "dek", 1000)

$Notify.Show()

#+END_SRC
* Daemon Management

Need to be able to configure the server file, since the defaults break w/ chemacs
https://www.gnu.org/software/emacs/manual/html_node/emacs/TCP-Emacs-server.html

https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/start-process?view=powershell-7
https://mcpmag.com/articles/2017/09/07/creating-a-balloon-tip-notification-using-powershell.aspx
https://github.com/proxb/PowerShell_Scripts/blob/master/Invoke-BalloonTip.ps1
https://community.spiceworks.com/topic/1874769-how-to-monitor-services-with-powershell
https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/convertfrom-json?view=powershell-7
** Process State Serialization
In order to do basic monitoring of the Emacs daemon, we serialize the process
object to and from a JSON file inside the working directory. We only need to
save the ID, but storing the entire process object is easier.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

PidFile = Join-Path $CackledaemonWD 'DaemonPidFile.json'

function Write-EmacsProcessToPidFile {
    param([System.Diagnostics.Process]$Process)

    ($Process).Id | ConvertTo-Json | Out-File PidFile
}

function Get-EmacsProcessFromPidFile {
    If (-not (Test-Path PidFile)) {
        return $null
    }

    $Id = (Get-Content PidFile | ConvertFrom-Json)

    If (-not $Id) {
        Remove-Item PidFile
        return $null
    }

    return Get-Process -Id $Id -ErrorAction SilentlyContinue
}

#+END_SRC
** Checking For Existing Daemons
It would probably be bad to try to start an Emacs daemon if one is already
running.

If an Emacs daemon is being managed, then retrieving the process state should be
successful and we can simply check to make sure that =Retrieve-ProcessFromPidFile=
returns a non-=$null= value. However, it's also possible to start the Emacs
daemon out-of-band, in which case we probably don't want to get involved either.
To check for this, we use [[https://docs.microsoft.com/en-us/powershell/module/cimcmdlets/get-ciminstance?view=powershell-7][CIM]] to find emacs processes and then check to see if
any of them have ~--daemon~ in their command line args. We intentionally punt on
the edge case of searching for emacs instances *not* started with the ~--daemon~
but which have called =(run-server)=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Get-UnmanagedEmacsDaemons () {
    $ManagedProcess = $(Get-EmacsProcessFromPidFile)
    return Get-CimInstance -Query "
        SELECT
          ,*
        FROM Win32_Process
        WHERE
          Name = 'emacs.exe' OR Name = 'runemacs.exe'
    " | Where-Object {
        $_.CommandLine.Contains("--daemon")
    } | ForEach-Object {
        Get-Process -Id ($_.ProcessId)
    } | Where-Object { -not ($_.Id -eq $ManagedProcess.Id) }
}

#+END_SRC
** Start the Emacs Daemon
This function launches the Emacs daemon (if it's not running already) with
sensible parameters and stores process info so we can do basic monitoring.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Start-EmacsDaemon {
    $Process = $(Get-EmacsProcessFromPidFile)

    If ($Process) {
        Throw [EmacsAlreadyRunningException]::new(
            'The Emacs daemon is already running and being managed!'
        )
    }

    If ($(Get-UnmanagedEmacsDaemons)) {
        Throw [EmacsAlreadyRunningException]::new(
            'The Emacs daemon has already been started by someone else and ' +
            'is not being managed!'
        )
    }

    Invoke-EnsureCackledaemonWD

    Write-CackledaemonLog "Starting the Emacs daemon..."

    $Process = Start-Process `
      -FilePath 'emacs.exe' `
      -ArgumentList '--daemon' `
      -NoNewWindow `
      -RedirectStandardOut $EmacsStdOutLogFile `
      -RedirectStandardError $EmacsStdErrLogFile `
      -PassThru

    Write-CackledaemonLog "Saving the Emacs daemon's process state..."

    Write-EmacsProcessToPidFile -Process $Process

    Write-CackledaemonLog 'Done.'

    return $Process
}

#+END_SRC
** Get the Emacs Daemon
We actually already have this, its name just isn't very ergonomic. We'll set it
as an alias here for convenience.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
Set-Alias -Name Get-EmacsDaemon Get-EmacsProcessFromPidFile

#+END_SRC
** Stop the Emacs Daemon
Stopping the process is simply a matter of retrieving the process state from
disk and attempting to stop the process.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Stop-EmacsDaemon {
    $Process = Get-EmacsProcessFromPidFile

    If (-not $Process) {
        Throw [EmacsNotRunningException]::new(
            "A managed Emacs daemon isn't running and can not be stopped!"
        )
    }

    Invoke-EnsureCackledaemonWD

    Write-CackledaemonLog 'Stopping the Emacs daemon...'

    Stop-Process -InputObject $Process

    Write-EmacsProcessToPidFile $null

    Write-CackledaemonLog 'Done.'
}

#+END_SRC
** Restart the Emacs Daemon
From here, restarting is easy - first stop the process, then start it again.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Restart-EmacsDaemon {
    Stop-EmacsDaemon
    Start-EmacsDaemon
}
#+END_SRC
* Installation Stuff
It turns out that installing emacs is unzipping a zipball, running a magic
program and manually doing a bunch of bullshit. I should just automate
installing and checking for updates too.

https://lists.gnu.org/archive/html/help-gnu-emacs/2004-03/msg00168.html
https://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Startup.html

#+BEGIN_SRC powershell
(
    Invoke-WebRequest https://mirrors.syringanetworks.net/gnu/emacs/windows/
).Links.Href | Where-Object { $_.StartsWith('emacs-') } | ForEach-Object {
    $_ -match 'emacs-(\d+)/'
    return $Matches[1]
}
#+END_SRC
* Exports
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
Export-ModuleMember `
  -Function @(
      'Invoke-EnsureCackledaemonWD',
      'Write-CackledaemonLog',
      'Get-CackledaemonLogRotateJob',
      'Start-CackledaemonLogRotateJob',
      'Stop-CackledaemonLogRotateJob',
      'Remove-CackledaemonLogRotateJob',
      'Start-EmacsDaemon',
      'Stop-EmacsDaemon',
      'Restart-EmacsDaemon',
      'Write-EmacsProcessToPidFile',
      'Get-EmacsProcessFromPidFile',
      'Get-UnmanagedEmacsDaemons'
  ) `
  -Variable @(
      'CackledaemonWD'
  ) `
  -Alias @(
      'Get-EmacsDaemon'
  )
#+END_SRC
* Manifest
https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psd1
@{
    RootModule = 'Cackledaemon.psm1'

    ModuleVersion = '0.0.12'
    GUID = '10d14360-ee5c-4363-bfe8-f4116a8ce764'

    Author = 'Josh Holbrook'
    Copyright = 'Copyright 2020 Josh Holbrook.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.'

    Description = 'An opinionated framework for managing the Emacs daemon in Windows'

    # Modules that must be imported into the global environment prior to importing this module
    # RequiredModules = @()

    # Assemblies that must be loaded prior to importing this module
    RequiredAssemblies = @('System.Windows.Forms')

    # Script files (.ps1) that are run in the caller's environment prior to importing this module.
    # ScriptsToProcess = @()

    # Modules to import as nested modules of the module specified in RootModule/ModuleToProcess
    # NestedModules = @()

    FunctionsToExport = @(
        'Invoke-EnsureCackledaemonWD'
        'Write-CackledaemonLog'
        'Start-CackledaemonLogRotateJob'
        'Get-EmacsProcessFromPidFile'
        'Write-EmacsProcessToPidFile'
        'Start-EmacsDaemon'
        'Stop-EmacsDaemon'
        'Restart-EmacsDaemon'
    )

    CmdletsToExport = @()
    VariablesToExport = @(
        'CackledaemonWD'
    )
    AliasesToExport = @(
        'Get-EmacsDaemon'
    )

    FileList = @('Cackledaemon.psm1', 'Cackledaemon.psd1', 'COPYING')
    ModuleList = @('.\Cackledaemon.psm1')

    PrivateData = @{
        PSData = @{
            Tags = @('emacs')
            LicenseUri = 'https://github.com/jfhbrook/cackledaemon/blob/master/COPYING'
            ProjectUri = 'https://github.com/jfhbrook/cackledaemon'

            # A URL to an icon representing this module.
            # IconUri = ''

            # ReleaseNotes of this module
            # ReleaseNotes = ''
        }
    }

    # HelpInfo URI of this module
    # https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-create-a-helpinfo-xml-file?view=powershell-7
    # HelpInfoURI = ''

    # Default prefix for commands exported from this module. Override the default prefix using Import-Module -Prefix.
    # DefaultCommandPrefix = ''

}

#+END_SRC
* Development Tasks :export:
Cackledaemon can be built and published using [[https://github.com/nightroman/Invoke-Build][Invoke-Build]].
** Building Cackledaemon
=Invoke-Build= will call Emacs in batch mode to build this project using
~org-babel~. Alternately, you may type ~C-c C-v t~ with this file open in Emacs.

This emacs batch script tangles ~cackledaemon.org~ and generates the ~README.md~:

#+BEGIN_SRC emacs-lisp :tangle build.el
(progn
  (require 'org)
  (require 'ob-tangle)
  (require 'ox-md)

  (with-current-buffer (find-file-noselect "cackledaemon.org")
    (message "Tangling Code...")
    (org-babel-tangle)
    (message "Generating README...")
    (org-export-to-file 'md "README.md"))
  (message "Done."))
#+END_SRC

=Invoke-Build= wraps this in a task which shells out to Emacs:

#+BEGIN_SRC powershell :tangle Cackledaemon.build.ps1
task . Build

task Build {
    emacs.exe --batch --load build.el
    Remove-Item README.md~
}

#+END_SRC
** Publishing Cackledaemon
This project can be published on the Powershell Gallery by running
=Invoke-Build Publish.= In order for it to succeed, there must be a
=.\Secrets.ps1= file that defines =$PowershellGalleryAPIKey= as a valid
Powershell Gallery NuGet API key. This file gets sourced by the ~Publish~ task.

#+BEGIN_SRC powershell :tangle Cackledaemon.build.ps1
task Publish Build, {
    . .\Secrets.ps1
     Publish-Module -Path .\Cackledaemon\ -NuGetApiKey $PowershellGalleryAPIKey
}
#+END_SRC

* License :export:
Cackledaemon, much like Emacs, is licensed under the terms of the GPL v3 or
newer.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
# Copyright 2020 Josh Holbrook
#
# This file is part of Cackledaemon.
#
# Cackledaemon is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Cackledaemon is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cackledaemon.  If not, see <https://www.gnu.org/licenses/>.


#+END_SRC
