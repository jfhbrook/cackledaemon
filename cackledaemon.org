#+TITLE: Cackledaemon - An Emacs Installation and Runtime Manager for Windows
#+AUTHOR: Josh Holbrook
#+OPTIONS: tags:nil toc:nil

* Introduction :export:
#+BEGIN_QUOTE
Oh-ho-ho! Swirly Photoshop magic! I bet this thing could release some serious
cackledemons!

-- Strong Bad
#+END_QUOTE

Anyone who has used a fully configured [[https://www.gnu.org/software/emacs/][Emacs]] install such as [[https://www.spacemacs.org/][Spacemacs]] or [[https://github.com/hlissner/doom-emacs][Doom]]
knows that Emacs can take a long time to initially boot. This isn't for a lack
of trying - in fact, the source code for Doom is half speed hacks and I highly
encourage anybody hacking on Emacs to take a look.

The truth is that Emacs is less a code editor and more of a *framework* for
*writing text-based applications*. I like to compare it to [[https://nodejs.org][Node.js]] in this
regard, which, while really good at being a webserver is no [[https://www.nginx.com/][NGINX]], but instead a
runtime where you can import lots of tiny pieces of functionality a la carte to
make your own webserver. Any one of these configurations does exactly this - it
installs packages from the internet, requires them and uses [[https://www.gnu.org/software/emacs/manual/html_node/eintr/][Emacs Lisp]] to create
a complete application. Spacemacs and Doom are built similarly, but feel
different because they *are* in fact meaningfully different.

Just as you don't want to load the JavaScript runtime for every request (this is
how non-Node webservers [[https://en.wikipedia.org/wiki/Common_Gateway_Interface][used to do in the olden days]] and trust me it was not
very good) you don't really want to load all of Emacs every time you open a file
either. It's less than ideal.

Luckily for us, Emacs can be ran [[https://www.emacswiki.org/emacs/EmacsAsDaemon][as a daemon]] and connected to via a client,
typically ~emacsclient~. In Linux and [[https://www.freedesktop.org/wiki/Software/systemd/][systemd]] this works seamlessly - often you
can run =systemctl start --user emacs= and be off to the races. In OSX it's only
a little harder - you [[https://www.emacswiki.org/emacs/EmacsAsDaemon#toc8][copy-paste a plist file from the wiki]], pull some very
minor shenanigans and have a mostly working daemon.

In Windows it's a bit more of a mess. This is because the Windows abstractions
for processes and services are wildly divergent from those in nix-like
environments such as Linux and OSX. Init systems like systemd run and manage
normal process, meanwhile in Windows services are in fact [[https://docs.microsoft.com/en-us/dotnet/framework/windows-services/walkthrough-creating-a-windows-service-application-in-the-component-designer][special programs]] that
[[https://docs.microsoft.com/en-us/dotnet/api/system.serviceprocess?view=netframework-4.8][expose an alternate interface]] to that of the standard process. The upshot is
that any standard process that one wants to run as a Windows service needs to be
wrapped in one of these special programs, complete with bespoke abstractions for
process management, log management and so on.

Alternately, arbitrary processes may be [[https://support.microsoft.com/en-us/help/4026268/windows-10-change-startup-apps][configured to start on user login]].
Practically speaking, this is how most persistent applications are ran in
Windows, and in fact the [[https://www.emacswiki.org/emacs/EmacsMsWindowsIntegration#toc8][approach documented in the wiki]] does exactly this - it
uses a Powershell script to generate a very simple [[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands][batch file]] that cleans up
server state from the prior run and then spawns the Emacs daemon.

This works OK. However, there are some downsides. if the Emacs daemon crashes
for any reason, there's no signal other than ~emacsclient~ mysteriously not
working; any logs that come out of the Emacs daemon are lost to the aether; and
straightforward lifecycle actions that can be done casually with systemd (start,
top, restart, status) are very non-ergonomic.

Luckily, [[https://docs.microsoft.com/en-us/powershell/scripting/overview][PowerShell]] has our back. PowerShell is a shockingly good language - it
performs admirably as a shell and yet scales to general purpose use, even being
capable of making proper [[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes][.NET classes]]. More to the point, it's very good at
[[https://docs.microsoft.com/en-us/powershell/scripting/samples/managing-processes-with-process-cmdlets][managing processes]] and has [[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/background-jobs][special support for background jobs]], as well as being
able to [[https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.notifyicon][instantiate and manage tray icons]] via [[https://docs.microsoft.com/en-us/dotnet/framework/winforms/][Windows Forms]]. All it needs is a
little elbow grease!

Cackledaemon is a PowerShell module that intends to be a solution for managing
such an instance of the Emacs daemon for Windows. It includes functions for
starting, stopping and restarting the Emacs daemon, functions and jobs for log
management and rotation, and a tray icon for a lil' point-and-click action and
notifications for if/when Emacs exits unexpectedly.

* Installing Cackledaemon
#+BEGIN_SRC powershell :tangle ./Installer.ps1
#Requires -Version 5.1

Write-Host 'Welcome to the Cackledaemon install wizard!'
Write-Host ''
Write-Host 'This script will guide you through the process of installing/updating Cackledaemon and Emacs.'
Write-Host ''

$InstalledModule = Get-InstalledModule 'Cackledaemon'

if ($InstalledModule) {
    Write-Host "Cackledaemon is already installed, but there might be " -NoNewLine
    Write-Host "updates..!" -ForegroundColor Yellow -NoNewLine
    Write-Host " :)"
    Write-Host "This script can " -NoNewLine
    Write-Host "optionally" -ForegroundColor Green -NoNewLine
    Write-Host " update the Cackledaemon module for " -NoNewLine
    Write-Host "all users" -ForegroundColor Red -NoNewLine
    Write-Host ". It requires, and will prompt for, " -NoNewLine
    Write-Host "Administrator privileges" -ForegroundColor Cyan -NoNewLine
    Write-Host '.'

    $InstallCackledaemonChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Reinstall the Cackledaemon module for all users. This will install module updates."
    $DontInstallCackledaemonChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Don't reinstall the Cackledaemon module. It's already installed, but there may be updates."

    $InstallCackledaemon = -not [boolean]$host.UI.PromptForChoice( `
      "Do you want to reinstall Cackledaemon?", `
      "Whaddaya think?", `
      @($InstallCackledaemonChoice, $DontInstallCackledaemonChoice), `
      0 `
    )
} else {
    Write-Host "Cackledaemon " -NoNewLine
    Write-Host "needs to be installed!" -ForegroundColor Yellow
    Write-Host "This script will install the Cackledaemon module for " -NoNewLine
    Write-Host "all users" -ForegroundColor Red -NoNewLine
    Write-Host ". It requires, and will prompt for, " -NoNewLine
    Write-Host "Administrator privileges" -ForegroundColor Cyan -NoNewLine
    Write-Host "."

    $InstallCackledaemonChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Install the Cackledaemon module for all users. This is required in order to use Cackledaemon."
    $DontInstallCackledaemonChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Don't install the Cackledaemon module. This will abort the installation process."

    $InstallCackledaemon = -not [boolean]$host.UI.PromptForChoice( `
      "Do you want to install Cackledaemon?", `
      "Whaddaya think?", `
      @($InstallCackledaemonChoice, $DontInstallCackledaemonChoice), `
      0 `
    )
}
Write-Host ''

if ($InstallCackledaemon) {
    Write-Host 'Installing the Cackledaemon module...'
    Start-Process -Wait -Verb RunAs powershell.exe -ArgumentList '-Command', "& {
        Write-Host 'Installing the Cackledaemon module...'
        Install-Module -Force Cackledaemon
        Write-Host 'All done!'
    }"
} elseif (-not $InstalledModule) {
    Write-Host 'Cackledaemon is ' -NoNewLine
    Write-Host 'not installed' -ForegroundColor Red -NoNewLine
    Write-Host ' and the script can not continue.'
    Write-Host 'Have a nice day!'
    Exit
}

Import-Module Cackledaemon

if (Test-Path $CackledaemonWD) {
    Write-Host "$CackledaemonWD already exists - nothing to do here!"
} else {
    Write-Host "Time to initialize " -NoNewLine
    Write-Host $CackledaemonWD -ForegroundColor Yellow -NoNewLine
    Write-Host "!"

    $ModuleDirectory = Split-Path -Path (Get-Module Cackledaemon).Path -Parent
    $StartMenuPath = Join-Path $Env:AppData 'Microsoft\Windows\Start Menu\Programs\Gnu Emacs'
    $ShortcutsCsvPath = Join-Path $ModuleDirectory 'Shortcuts.csv'
    $FileTypeAssociationsCsvPath = Join-Path $ModuleDirectory 'FileTypeAssociations.csv'

    Write-Host "By default, Cackledaemon will " -NoNewLine
    Write-Host "create these shortcuts" -ForegroundColor Green -NoNewLine
    Write-Host " inside the 'GNU Emacs' folder in the user's Start Menu when installing Emacs:"
    Write-Host ''

    Import-Csv -Path $ShortcutsCsvPath | ForEach-Object {
        Write-Host "- " -NoNewLine
        Write-Host ("{0}\{1}.lnk" -f $StartMenuPath, $_.ShortcutName) -ForegroundColor Green -NoNewLine
        Write-Host " -> " -NoNewLine
        Write-Host $_.EmacsBinaryName -ForegroundColor Yellow
    } | Out-Null
    Write-Host ''
    Write-Host "You may " -NoNewLine
    Write-Host "edit this config" -ForegroundColor Cyan -NoNewLine
    Write-Host " at " -NoNewLine
    Write-Host "$CackledaemonWD\Shortcuts.csv" -ForegroundColor Yellow -NoNewLine
    Write-Host " and re-run the Emacs install step at " -NoNewLine
    Write-Host "any time" -ForegroundColor Green -NoNewLine
    Write-Host " to change these shortcuts."

    $InstallShortcutsChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Create these shortcuts in the Start Menu. You can edit this CSV and re-run this step at any time."
    $DontInstallShortcutsChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Don't create any shortcuts in the Start Menu at this time. You can create a fresh CSV and re-run this step at any time."

    $NoShortcuts = [boolean]$host.UI.PromptForChoice( `
      "Do you want to use these shortcuts?", `
      "Whaddaya think?", `
      @($InstallShortcutsChoice, $DontInstallShortcutsChoice), `
      0
    )
    Write-Host ''

    Write-Host "By default, Cackledaemon will " -NoNewLine
    Write-Host "create" -ForegroundColor Green -NoNewLine
    Write-Host " these " -NoNewLine
    Write-Host "system-wide" -ForegroundColor Red -NoNewLine
    Write-Host " file type associations:"
    Write-Host ""
    Import-Csv -Path $FileTypeAssociationsCsvPath | ForEach-Object {
        Write-Host "- " -NoNewLine
        Write-Host $_.Extension -ForegroundColor Green -NoNewLine
        Write-Host " -(" -NoNewLine
        Write-Host $_.FileType -ForegroundColor Cyan -NoNewLine
        Write-Host ")-> " -NoNewLine
        Write-Host $_.Command -ForegroundColor Yellow
    } | Out-Null
    Write-Host ""
    Write-Host "You may " -NoNewLine
    Write-Host "edit this config" -ForegroundColor Cyan -NoNewLine
    Write-Host " at " -NoNewLine
    Write-Host "$CackledaemonWD\FileTypeAssociations.csv" -ForegroundColor Yellow -NoNewLine
    Write-Host " and re-run the Emacs install step at " -NoNewLine
    Write-Host "any time" -ForegroundColor Green -NoNewLine
    Write-Host " to create new associations. You may also " -NoNewLine
    Write-Host "manually create " -ForegroundColor Cyan -NoNewLine
    Write-Host "user-level" -ForegroundColor Green -NoNewLine
    Write-Host " file type associations inside " -NoNewLine
    Write-Host "Windows Explorer" -ForegroundColor Cyan -NoNewLine
    Write-Host '.'

    $InstallAssociationsChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Create these file type associations for all users. You can edit this CSV and re-run this step at any time."
    $DontInstallAssociationsChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Don't create any file type associations. You can edit this CSV and re-run this step at any time."

    $NoFileTypeAssociations = [boolean]$host.UI.PromptForChoice( `
      "Do you want to use these file type associations?", `
      "Whaddaya think?", `
      @($InstallAssociationsChoice, $DontInstallAssociationsChoice), `
      0
    )

    Write-Host "Initializing $CackledaemonWD..."
    New-CackledaemonWD -NoShortcuts $NoShortcuts -NoFileTypeAssociations $NoFileTypeAssociations | Out-Null

}

Write-Host "Checking the state of Emacs..."
Write-Host ''

$EmacsCommand = Get-Command 'emacs.exe'

if ($EmacsCommand) {
    if (Test-EmacsExe) {
        Write-Host "Emacs is already installed but it couldn't hurt to check for " -NoNewLine
        Write-Host "updates..! :)" -ForegroundColor Yellow
        Write-Host "This script can " -NoNewLine
        Write-Host "optionally" -ForegroundColor Green -NoNewLine
        Write-Host " install updates to Emacs for " -NoNewLine
        Write-Host "all users" -ForegroundColor Red -NoNewLine
        Write-Host ". It requires, and will prompt for, " -NoNewLine
        Write-Host "Administrator privileges" -ForegroundColor Cyan -NoNewLine
        Write-Host '.'

        $InstallEmacsChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Check for and install any available Emacs updates."
        $DontInstallEmacsChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Don't check for Emacs updates. Emacs is already installed, so this is probably OK. You can run this manually at any time by importing the Cackledaemon module and running 'Install-Emacs'."
        $InstallEmacs = -not [boolean]$host.UI.PromptForChoice( `
            "Do you want to check for updates to Emacs?", `
            "Whaddaya think?", `
            @($InstallEmacsChoice, $DontInstallEmacsChoice), `
            0 `
        )
    } else {
        Write-Host "An " -NoNewLine
        Write-Host "unmanaged Emacs" -ForegroundColor Red -NoNewLine
        Write-Host " is " -NoNewLine
        Write-Host "already on your `$Path" -ForegroundColor Red -NoNewLine
        Write-Host "! This script will probably cause " -NoNewLine
        Write-Host "surprising behavior" -ForegroundColor Yellow -NoNewLine
        Write-Host " but is " -NoNewLine
        Write-Host "game to try" -ForegroundColor Cyan -NoNewLine
        Write-Host "!"

        $InstallEmacsChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Install a managed Emacs alongside the unmanaged Emacs version already detected. This will likely cause surprising behavior - it is recommended that you read the manual before continuing."
        $DontInstallEmacsChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Don't install a managed Emacs. This is the safest choice, but means that you can't take advantage of Cackledaemon's features. You can run this manually at any time by importing the Cackledaemon module and running 'Install-Emacs'."
        $InstallEmacs = -not [boolean]$host.UI.PromptForChoice( `
            "Do you want to install a managed Emacs alongside the version of Emacs already installed?", `
            "Whaddaya think?", `
            @($InstallEmacsChoice, $DontInstallEmacsChoice), `
            1 `
        )
    }
} else {
    Write-Host "Emacs " -NoNewLine
    Write-Host "needs to be installed!" -ForegroundColor Yellow
    Write-Host "This script will install Emacs for " -NoNewLine
    Write-Host "all users" -ForegroundColor Red -NoNewLine
    Write-Host ". It requires, and will prompt for, " -NoNewLine
    Write-Host "Administrator privileges" -ForegroundColor Cyan -NoNewLine
    Write-Host "."

    $InstallEmacsChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Install Emacs. This is required in order to use Cackledaemon and Emacs."
    $DontInstallEmacsChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Don't install Emacs. This will abort the installation process."
    $InstallEmacs = -not [boolean]$host.UI.PromptForChoice( `
        "Do you want to install Emacs?", `
        "Whaddaya think?", `
        @($InstallEmacsChoice, $DontInstallEmacsChoice), `
        0 `
    )
}

if ($InstallEmacs) {
    Write-Host 'Installing Emacs...'
    Install-Emacs
} else {
    Write-Host 'Not installing Emacs.'
}

if (-not (Test-EmacsExe)) {
    Write-Host 'Emacs is ' -NoNewLine
    Write-Host 'not installed' -ForegroundColor Red -NoNewLine
    Write-Host ' and the script can not continue.'
    Write-Host 'Have a nice day!'
    Exit
}

Write-Host ''
Write-Host "Cackledaemon can also set up the " -NoNewLine
Write-Host "user's " -ForegroundColor Cyan -NoNewLine
Write-Host " environment by configuring the user's `$Path and `$HOME and by creating shortcuts. This touches the user's " -NoNewLine
Write-Host "registry" -ForegroundColor Yellow -NoNewLine
Write-Host " but doesn't require Administrator privileges."

$InstallEnvironmentChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Set up the user's environment for Emacs. This isn't strictly required but is nice to have."
$DontInstallEnvironmentChoice = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Don't set up the user's environment for Emacs. Emacs will be installed but it will be tough for the user to run."
$InstallEnvironment = -not [boolean]$host.UI.PromptForChoice( `
  "Do you want to set up the user environment?",
  "Whaddaya think?", `
  @($InstallEnvironmentChoice, $DontInstallEnvironmentChoice), `
  0 `
)

if ($InstallEnvironment) {
    Write-Host "Setting up the user's environment..."
    Install-EmacsUserEnvironment
} else {
    Write-Host "Not touching the user's environment."
}
Write-Host "Have a nice day!"

#+END_SRC
* Configuration and State
** Working Directory
Cackledaemon needs a place to store configurations, logs and process metadata.
For this purpose, we create a folder at =$Env:AppData\Cackledaemon=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
$CackledaemonWD = Join-Path $Env:AppData 'Cackledaemon'
$CackledaemonConfigLocation = Join-Path $CackledaemonWD 'Configuration.ps1'

function New-CackledaemonWD {
    param(
        [switch]$NoShortcuts,
        [switch]$NoFileTypeAssociations
    )
    New-Item -Path $CackledaemonWD -ItemType directory

    $ModuleDirectory = Split-Path -Path (Get-Module Cackledaemon).Path -Parent

    Copy-Item (Join-Path $ModuleDirectory 'Configuration.ps1') (Join-Path $CackledaemonWD 'Configuration.ps1')

    if (-not $NoShortcuts) {
        Copy-Item (Join-Path $ModuleDirectory 'Shortcuts.csv') (Join-Path $CackledaemonWD 'Shortcuts.csv')
    }

    if (-not $NoFileTypeAssociations) {
        Copy-Item (Join-Path $ModuleDirectory 'FileTypeAssociations.csv') (Join-Path $CackledaemonWD 'FileTypeAssociations.csv')
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
function Initialize-TestEnvironment {
    $Global:OriginalAppData = $Env:AppData
    $Global:OriginalProgramFiles = $Env:ProgramFiles
    $Global:OriginalUserProfile = $Env:UserProfile
    $Global:OriginalModulePath = (Get-Module 'Cackledaemon').Path

    $Env:AppData = "$TestDrive\AppData"
    $Env:ProgramFiles = "$TestDrive\Program Files"

    $Env:UserProfile = "$TestDrive\UserProfile"

    New-Item -Type Directory $Env:AppData
    New-Item -Type Directory $Env:ProgramFiles
    New-Item -Type Directory $Env:UserProfile

    Remove-Module Cackledaemon -ErrorAction 'SilentlyContinue'
    Import-Module .\Cackledaemon\Cackledaemon.psd1

    $Global:CackledaemonWD = "$TestDrive\Cackledaemon"
    $Global:CackledaemonConfigLocation = "$TestDrive\Cackledaemon\Configuration.ps1"

    New-CackledaemonWD
}

function Restore-StandardEnvironment {
    $Env:AppData = $Global:OriginalAppData
    $Env:ProgramFiles = $Global:OriginalProgramFiles
    $Env:UserProfile = $Global:OriginalUserProfile

    Remove-Item -Recurse "$TestDrive\AppData"
    Remove-Item -Recurse "$TestDrive\Program Files"
    Remove-Item -Recurse "$TestDrive\UserProfile"
    Remove-Item -Recurse "$TestDrive\Cackledaemon"

    Remove-Module Cackledaemon

    if ($Global:OriginalModulePath) {
        Import-Module $Global:OriginalModulePath
    }
}

Describe "New-CackledaemonWD" {
    BeforeEach {
        Initialize-TestEnvironment
        Remove-Item -Recurse "$TestDrive\Cackledaemon"
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when shortcuts and file type associations are both enabled' {
        It "creates a new and initialized working directory" {
            New-CackledaemonWD

            'TestDrive:\Cackledaemon' | Should -Exist
            'TestDrive:\Cackledaemon\Configuration.ps1' | Should -Exist
            'TestDrive:\Cackledaemon\Shortcuts.csv' | Should -Exist
            'TestDrive:\Cackledaemon\FileTypeAssociations.csv' | Should -Exist
        }
    }

    Context 'when shortcuts are disabled' {
        It "creates a new and initialized working directory without shortcuts" {
            New-CackledaemonWD -NoShortcuts

            'TestDrive:\Cackledaemon' | Should -Exist
            'TestDrive:\Cackledaemon\Configuration.ps1' | Should -Exist
            'TestDrive:\Cackledaemon\Shortcuts.csv' | Should -Not -Exist
            'TestDrive:\Cackledaemon\FileTypeAssociations.csv' | Should -Exist
        }
    }

    Context 'when file type associations are disabled' {
        It "creates a new and initialized working directory without file type associations" {
            New-CackledaemonWD -NoFileTypeAssociations

            'TestDrive:\Cackledaemon' | Should -Exist
            'TestDrive:\Cackledaemon\Configuration.ps1' | Should -Exist
            'TestDrive:\Cackledaemon\Shortcuts.csv' | Should -Exist
            'TestDrive:\Cackledaemon\FileTypeAssociations.csv' | Should -Not -Exist
        }
    }

    Context 'when both shortcuts and file type associations are disabled' {
        It "creates a new and initialized working directory without file type associations" {
            New-CackledaemonWD -NoShortcuts -NoFileTypeAssociations

            'TestDrive:\Cackledaemon' | Should -Exist
            'TestDrive:\Cackledaemon\Configuration.ps1' | Should -Exist
            'TestDrive:\Cackledaemon\Shortcuts.csv' | Should -Not -Exist
            'TestDrive:\Cackledaemon\FileTypeAssociations.csv' | Should -Not -Exist
        }
    }
}

#+END_SRC
** Base Config File
Most Cackledaemon settings live in ~Configuration.ps1~. These settings can be
loaded by sourcing the script.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Configuration.ps1
# Installer Settings
$WorkspaceDirectory = Join-Path $CackledaemonWD 'Workspace'
$EmacsDownloadsEndpoint = 'https://ftp.gnu.org/gnu/emacs/windows/'
$EmacsInstallLocation = Join-Path $Env:ProgramFiles 'emacs'
$StartMenuPath = Join-Path $Env:AppData 'Microsoft\Windows\Start Menu\Programs\Gnu Emacs'

# Emacs Settings
$HomeDirectory = $Env:UserProfile
$ServerFileDirectory = Join-Path $Env:UserProfile '.emacs.d/server'

# Logging Settings
$CackledaemonLogFile = Join-Path $CackledaemonWD 'Cackledaemon.log'
$EmacsStdOutLogFile = Join-Path $CackledaemonWD 'EmacsStdOut.log'
$EmacsStdErrLogFile = Join-Path $CackledaemonWD 'EmacsStdErr.log'
$LogSize = 1mb
$LogRotate = 4
$LogCheckTime = 60  # Seconds

# Daemon Management Settings
$PidFile = Join-Path $CackledaemonWD 'DaemonPidFile.json'

# Applet Settings
$NotifyTimeout = 5000
#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Configuration.ps1' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'defines base settings' {
        . $CackledaemonConfigLocation

        $WorkspaceDirectory | Should -Be "$TestDrive\Cackledaemon\Workspace"
        $EmacsDownloadsEndpoint | Should -Be 'https://ftp.gnu.org/gnu/emacs/windows/'
        $EmacsInstallLocation | Should -Be "$TestDrive\Program Files\emacs"
        $StartMenuPath | Should -Be "$TestDrive\AppData\Microsoft\Windows\Start Menu\Programs\Gnu Emacs"

        $CackledaemonLogFile | Should -Be "$TestDrive\Cackledaemon\Cackledaemon.log"
        $EmacsStdOutLogFile | Should -Be "$TestDrive\Cackledaemon\EmacsStdOut.log"
        $EmacsStdErrLogFile | Should -Be "$TestDrive\Cackledaemon\EmacsStdErr.log"
        $LogSize | Should -Be 1mb
        $LogRotate | Should -Be 4
        $LogCheckTime | Should -Be 60

        $NotifyTimeout | Should -Be 5000
    }
}

#+END_SRC
** Start Menu Shortcuts Config
The desired state of Start menu shortcuts are stored in a CSV file. Note that
the ~TYPE~ header is necessary, and the ~$ArgumentList~ is double-encoded as a
JSON array.

#+BEGIN_SRC csv :tangle ./Cackledaemon/Shortcuts.csv
#TYPE ShortcutCsvRecord
"ShortcutName","EmacsBinaryName","ArgumentList","Description"
EmacsClient,emacsclientw.exe,"[]",GNU EmacsClient: The client for the extensible self-documenting text editor
#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
class ShortcutCsvRecord {
    [string]$ShortcutName
    [string]$EmacsBinaryName
    [string]$ArgumentList
    [string]$Description

    ShortcutCsvRecord(
        [string]$ShortcutName,
        [string]$EmacsBinaryName,
        [string]$ArgumentList,
        [string]$Description
    ) {
        $this.ShortcutName = $ShortcutName
        $this.EmacsBinaryName = $EmacsBinaryName
        $this.ArgumentList = $ArgumentList
        $this.Description = $Description
    }
}

class ShortcutRecord {
    [string]$ShortcutName
    [string]$EmacsBinaryName
    [string[]]$ArgumentList
    [string]$Description

    ShortcutRecord(
        [string]$ShortcutName,
        [string]$EmacsBinaryName,
        [string[]]$ArgumentList,
        [string]$Description
    ) {
        $this.ShortcutName = $ShortcutName
        $this.EmacsBinaryName = $EmacsBinaryName
        $this.ArgumentList = $ArgumentList
        $this.Description = $Description
    }
}

function Get-ShortcutsConfig {
    Import-Csv -Path (Join-Path $CackledaemonWD './Shortcuts.csv') | ForEach-Object {
        New-Object ShortcutRecord $_.ShortcutName, $_.EmacsBinaryName, ($_.ArgumentList | ConvertFrom-Json), $_.Description
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Get-ShortcutsConfig' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'loads shortcuts settings' {
        $Config = Get-ShortcutsConfig

        $Config | Should -Not -Be $null

        $Config.length | Should -Be 1

        $Config[0].ShortcutName | Should -Be 'EmacsClient'
        $Config[0].EmacsBinaryName | Should -Be 'emacsclientw.exe'
        $Config[0].ArgumentList | Should -Be @()
        $Config[0].Description | Should -Be 'GNU EmacsClient: The client for the extensible self-documenting text editor'
    }
}

#+END_SRC
** File Type Associations Config
Desired file type associations are also stored in a CSV file. Note that the
~TYPE~ header is necessary. The format of the command string is detailed in [[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/ftype][the
documentation for the ~ftype~ batch command.]]

#+BEGIN_SRC csv :tangle ./Cackledaemon/FileTypeAssociations.csv
#Type FileTypeAssociationCsvRecord
"FileType","Extension","Command"
Gnu.Emacs.Org,.org,emacsclientw.exe -c -a notepad.exe %1
Gnu.Emacs.ELisp,.el,emacsclientw.exe -c -a notepad.exe %1
#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
class FileTypeAssociationRecord {
    [string]$FileType
    [string]$Extension
    [string]$Command

    FileTypeAssociationRecord(
        [string]$FileType,
        [string]$Extension,
        [string]$Command
    ) {
        $this.FileType = $FileType
        $this.Extension = $Extension
        $this.Command = $Command
    }
}

class FileTypeAssociationCsvRecord : FileTypeAssociationRecord {
    FileTypeAssociationCsvRecord([string]$FileType, [string]$Extension, [string]$Command): base($FileType, $Extension, $Command) {}
}

function Get-FileTypeAssociationsConfig {
    Import-Csv -Path (Join-Path $CackledaemonWD './FileTypeAssociations.csv') | ForEach-Object {
        New-Object FileTypeAssociationRecord $_.FileType, $_.Extension, $_.Command
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Get-FileTypeAssociationsConfig' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'loads file type association settings' {
        $Config = Get-FileTypeAssociationsConfig

        $Config | Should -Not -Be $null

        $Config.length | Should -Be 2

        $Config[0].FileType | Should -Be 'Gnu.Emacs.Org'
        $Config[0].Extension | Should -Be '.org'
        $Config[0].Command | Should -Be 'emacsclientw.exe -c -a notepad.exe %1'

        $Config[1].FileType | Should -Be 'Gnu.Emacs.ELisp'
        $Config[1].Extension | Should -Be '.el'
        $Config[1].Command | Should -Be 'emacsclientw.exe -c -a notepad.exe %1'
    }
}
#+END_SRC
* Job Management
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Enable-Job {
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [string]$Name,
        [Parameter(Position=1)]
        [ScriptBlock]$ScriptBlock
    )

    $Job = Get-Job -Name $Name -ErrorAction SilentlyContinue

    if ($Job) {
        Write-LogWarning ('{0} job already exists. Trying to stop and remove...' -f $Name)
            Disable-Job -Name $Job.Name -ErrorAction Stop

    }

    $Job = Get-Job -Name $Name -ErrorAction SilentlyContinue

    if ($Job) {
        Write-LogError -Message ('{0} job somehow still exists - not attempting to start a new one.' -f $Name) `
          -Category 'ResourceExists' `
          -CategoryActivity 'Enable-Job' `
          -CategoryReason 'UnstoppableJobException'
    } else {
        Start-Job `
          -Name $Name `
          -InitializationScript {
              Import-Module Cackledaemon
          } `
          -ScriptBlock $ScriptBlock
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe "Enable-Job" {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context "when a job doesn't exist" {
        It "creates a new job" {
            Stop-Job -Name 'testJob' -ErrorAction SilentlyContinue
            Remove-Job -Name 'testJob' -ErrorAction SilentlyContinue

            Enable-Job "testJob" {} -ErrorAction Stop

            $Job = Get-Job -Name 'testJob'
            $Job | Should -Not -Be $null

            Stop-Job -Id $Job.Id
            Remove-Job -Id $Job.Id
        }
    }

    Context "when a job already exists" {
        It 'disables and then creates a new job' {
            Stop-Job -Name 'testJob' -ErrorAction SilentlyContinue
            Remove-Job -Name 'testJob' -ErrorAction SilentlyContinue

            Start-Job -Name 'testJob' -ScriptBlock {}

            Enable-Job "testJob" {} -ErrorAction Stop -WarningVariable Warnings 3> $null

            $Warnings | Should -Not -Be $null
            $Warnings.Count | Should -Be 1

            $Warnings[0].ToString() | Should -Be "testJob job already exists. Trying to stop and remove..."

            $Job = Get-Job -Name 'testJob'

            $Job | Should -Not -Be $null
            $Job.length | Should -Be 1

            Stop-Job -Id $Job.Id
            Remove-Job -Id $Job.Id
        }
    }
}
#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Disable-Job {
    [CmdletBinding()]
    param(
        [Parameter(Position=0)]
        [string]$Name
    )

    $Job = Get-Job -Name $Name -ErrorAction SilentlyContinue

    if (-not $Job) {
        Write-LogWarning ("{0} job doesn't exist. Doing nothing." -f $Name)
        return
    }

    try {
        Stop-Job -Name $Name -ErrorAction Stop
        Remove-Job -Name $Name -ErrorAction Stop
    } catch {
        Write-LogError -Message ('Failed to stop and remove {0} job.' -f $Name) `
            -Exception $_.Exception `
            -Category $_.CategoryInfo.Category `
            -CategoryActivity $_.CategoryInfo.Activity `
            -CategoryReason $_.CategoryInfo.Reason `
            -CategoryTargetName $_.CategoryInfo.TargetName `
            -CategoryTargetType $_.CategoryInfo.TargetType
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe "Disable-Job" {
    Context "when a job exists" {
        It "disables the job" {
            Initialize-TestEnvironment

            Stop-Job -Name 'testJob' -ErrorAction SilentlyContinue
            Remove-Job -Name 'testJob' -ErrorAction SilentlyContinue

            Start-Job -Name 'testJob' -ScriptBlock {}

            Disable-Job "testJob" -ErrorAction Stop

            $Job = Get-Job -Name 'testJob' -ErrorAction SilentlyContinue
            $Job | Should -Be $null
        }
    }

    Context "when a job has already been removed" {
        It 'does nothing' {
            Initialize-TestEnvironment

            Stop-Job -Name 'testJob' -ErrorAction SilentlyContinue
            Remove-Job -Name 'testJob' -ErrorAction SilentlyContinue

            Disable-Job "testJob" -ErrorAction Stop -WarningVariable Warnings 3> $null

            $Warnings | Should -Not -Be $null
            $Warnings.length | Should -Be 1

            $Warnings[0].ToString() | Should -Be "testJob job doesn't exist. Doing nothing."

            $Job = Get-Job -Name 'testJob' -ErrorAction SilentlyContinue

            $Job | Should -Be $null
        }
    }
}
#+END_SRC
* Logging
** Logger
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Write-Log {
    param(
        [Parameter(Position=0)]
        [string]$Message,
        [string]$Level = 'Verbose',
        [Exception]$Exception,
        [System.Management.Automation.ErrorCategory]$Category = 'NotSpecified',
        [string]$CategoryActivity,
        [string]$CategoryReason,
        [string]$CategoryTargetName,
        [string]$CategoryTargetType
    )

    Try {
        . $CackledaemonConfigLocation
    } Catch {
        Write-Warning 'Unable to load configuration! Unable to write to log file.'
    }

    if (-not @('Debug', 'Verbose', 'Information', 'Host', 'Warning', 'Error').Contains($Level)) {
        Write-LogWarning ('Write-Log called with unrecognized level {0}' -f $Level)
        $Level = 'Warning'
    }

    if ($Level -eq 'Error' -and $Exception) {
        $Message = ('{0} (Exception: {1})' -f $Message, $Exception)
    }

    $Line = ('[{0}] {1}: {2}' -f (Get-Date -Format o), $Level, $Message)

    if ($CackledaemonLogFile) {
        Add-Content $CackledaemonLogFile -Value $Line
    }

    if ($Level -eq 'Debug') {
        Write-Debug $Message
    } elseif ($Level -eq 'Verbose') {
        Write-Verbose $Message
    } elseif ($Level -eq 'Information') {
        Write-Information $Message
    } elseif ($Level -eq 'Host') {
        Write-Host $Message
    } elseif ($Level -eq 'Warning') {
        Write-Warning $Message
    } elseif ($Level -eq 'Error') {
        if ($Exception) {
            Write-Error -Message $Message `
              -Exception $Exception `
              -Category $Category `
              -CategoryActivity $CategoryActivity `
              -CategoryReason $CategoryReason `
              -CategoryTargetName $CategoryTargetName `
              -CategoryTargetType $CategoryTargetType
        } else {
            Write-Error -Message $Message `
              -Category $Category `
              -CategoryActivity $CategoryActivity `
              -CategoryReason $CategoryReason `
              -CategoryTargetName $CategoryTargetName `
              -CategoryTargetType $CategoryTargetType
        }
    }
}

function Write-LogDebug {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Debug
}

function Write-LogInformation {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Information
}

function Write-LogHost {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Host
}

function Write-LogVerbose {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Verbose
}

function Write-LogWarning {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Warning
}

function Write-LogError {
    param(
        [Parameter(Position=0)]
        [string]$Message,
        [Exception]$Exception,
        [System.Management.Automation.ErrorCategory]$Category = 'NotSpecified',
        [string]$CategoryActivity,
        [string]$CategoryReason,
        [string]$CategoryTargetName,
        [string]$CategoryTargetType
    )

    if ($Exception) {
        Write-Log -Level Error `
          -Message $Message `
          -Exception $Exception `
          -Category $Category `
          -CategoryActivity $CategoryActivity `
          -CategoryReason $CategoryReason `
          -CategoryTargetName $CategoryTargetName `
          -CategoryTargetType $CategoryTargetType
    } else {
        Write-Log -Level Error `
          -Message $Message `
          -Category $Category `
          -CategoryActivity $CategoryActivity `
          -CategoryReason $CategoryReason `
          -CategoryTargetName $CategoryTargetName `
          -CategoryTargetType $CategoryTargetType
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
$TimestampRegexp = '\[\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{7}-\d{2}:\d{2}\]'

Describe 'Write-Log' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when the configuration is missing' {
        It 'warns and does nothing' {
            Remove-Item $CackledaemonConfigLocation

            Write-Log -Message "test log" -WarningVariable Warnings 3> $null

            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -Not -Exist

            $Warnings | Should -Not -Be $null
            $Warnings.Count | Should -Be 1
            $Warnings[0].ToString() | Should -Be 'Unable to load configuration! Unable to write to log file.'
        }
    }

    Context 'when called with an unrecognized level' {
        It 'warns and then logs at the warning level' {
            Write-Log -Level 'InvalidLevel' -Message 'Test Message' -WarningVariable Warnings 3> $null

            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -FileContentMatch "^$TimestampRegexp Warning: Write-Log called with unrecognized level InvalidLevel$"
            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -FileContentMatch "^$TimestampRegexp Warning: Test Message$"

            $Warnings | Should -Not -Be $null
            $Warnings.Count | Should -Be 2

            $Warnings[0].ToString() | Should -Be 'Write-Log called with unrecognized level InvalidLevel'
            $Warnings[1].ToString() | Should -Be 'Test Message'
        }
    }
}

@('Debug', 'Verbose', 'Information', 'Host', 'Warning') | ForEach-Object {
    Describe ('Write-Log{0}' -f $_) {
        BeforeEach {
            Initialize-TestEnvironment
        }

        AfterEach {
            Restore-StandardEnvironment
        }

        It ('logs at the {0} level' -f $_) {
            Mock -Module Cackledaemon Write-Host {}
           
            Invoke-Expression "Write-Log${_} 'Test message'" 3> $null

            "$TestDrive/Cackledaemon/Cackledaemon.log" | Should -FileContentMatch "^$TimestampRegexp ${_}: Test message$"
        }
    }
}

Describe 'Write-LogError' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when called with an exception type' {
        It 'logs an error' {
            $Exception = New-Object Exception 'Test exception'

            Write-LogError `
              'Test message' `
              -Exception (New-Object Exception 'Test exception') `
              -Category 'InvalidOperation' `
              -CategoryActivity 'Logging with an exception' `
              -CategoryReason 'Testing' `
              -CategoryTargetName 'SomeTarget' `
              -CategoryTargetType 'SomeTargetType' 2> $null

            $Error[0].ToString() | Should -Be 'Test message (Exception: System.Exception: Test exception)'
            $Error[0].CategoryInfo.Category.ToString() | Should -Be 'InvalidOperation'
            $Error[0].CategoryInfo.Reason | Should -Be 'Testing'
            $Error[0].CategoryInfo.TargetName | Should -Be 'SomeTarget'
            $Error[0].CategoryInfo.TargetType | Should -Be 'SomeTargetType'

            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -Exist
            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -FileContentMatch "^$TimestampRegexp Error: Test message \(Exception: System.Exception: Test exception\)$"
        }
    }

    Context 'when called without an exception type' {
        It 'logs an error' {
            Write-LogError `
              'Test message' `
              -Category 'InvalidOperation' `
              -CategoryActivity 'Logging without an exception' `
              -CategoryReason 'Testing' `
              -CategoryTargetName 'SomeTarget' `
              -CategoryTargetType 'SomeTargetType' 2> $null

            $Error[0].Exception | Should -Not -Be $null
            $Error[0].CategoryInfo.Category.ToString() | Should -Be 'InvalidOperation'
            $Error[0].CategoryInfo.Reason | Should -Be 'Testing'
            $Error[0].CategoryInfo.TargetName | Should -Be 'SomeTarget'
            $Error[0].CategoryInfo.TargetType | Should -Be 'SomeTargetType'

            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -Exist
            'TestDrive:/Cackledaemon/Cackledaemon.log' | Should -FileContentMatch "^$TimestampRegexp Error: Test Message$"
        }
    }
}


#+END_SRC
** Log Rotation
This function more or less tries to emulate a typical logrotate config - it
rotates the log if it's at or over a certain size, retains some finite count of
log files, and drops the last one if necessary.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Invoke-LogRotate {
    [CmdletBinding()]
    param()

    . $CackledaemonConfigLocation

    @($CackledaemonLogFile, $EmacsStdoutLogFile, $EmacsStdErrLogFile) | ForEach-Object {
        $LogFile = $_

        if ((Test-Path $LogFile) -and (Get-Item $LogFile).Length -ge $LogSize) {
            Write-LogVerbose ('Rotating {0}...' -f $LogFile)

            ($LogRotate..0) | ForEach-Object {
                $Current = $(if ($_) {
                    '{0}.{1}' -f $LogFile, $_
                } else { $LogFile })

                $Next = '{0}.{1}' -f $LogFile, ($_ + 1)

                if (Test-Path $Current) {
                    Write-LogVerbose ('Copying {0} to {1}...' -f $Current, $Next)

                    Copy-Item -Path $Current -Destination $Next
                }
            }

            Write-LogVerbose ('Truncating {0}...' -f $LogFile)

            Clear-Content $LogFile

            $StaleLogFile = '{0}.{1}' -f $LogFile, ($LogRotate + 1)

            if (Test-Path $StaleLogFile) {
                Write-LogVerbose ('Removing {0}...' -f $StaleLogFile)

                Remove-Item $StaleLogFile
            }

            Write-LogVerbose 'Done.'
        }
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Invoke-LogRotate' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'rotates the logs' {
        Add-Content 'TestDrive:\Cackledaemon\Configuration.ps1' '$LogSize = 1'
        Add-Content 'TestDrive:\Cackledaemon\Configuration.ps1' '$LogRotate = 2'

        Write-LogVerbose 'Testing 1'

        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -FileContentMatch 'Testing 1'
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -Not -Exist
        'TestDrive:\Cackledaemon\EmacsStdOut.log' | Should -Not -Exist
        'TestDrive:\Cackledaemon\EmacsStdErr.log' | Should -Not -Exist

        Invoke-LogRotate

        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Not -FileContentMatch 'Testing 1'
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -FileContentMatch 'Testing 1'

        Write-LogVerbose 'Testing 2'
        Invoke-LogRotate

        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Not -FileContentMatch 'Testing 2'
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -FileContentMatch 'Testing 2'
        'TestDrive:\Cackledaemon\Cackledaemon.log.2' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log.2' | Should -FileContentMatch 'Testing 1'

        Write-LogVerbose 'Testing 3'
        Invoke-LogRotate

        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log' | Should -Not -FileContentMatch 'Testing 3'
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log.1' | Should -FileContentMatch 'Testing 3'
        'TestDrive:\Cackledaemon\Cackledaemon.log.2' | Should -Exist
        'TestDrive:\Cackledaemon\Cackledaemon.log.2' | Should -FileContentMatch 'Testing 2'
        'TestDrive:\Cackledaemon\Cackledaemon.log.3' | Should -Not -Exist
    }
}

#+END_SRC

We can also use a job to manage log rotation.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Enable-LogRotateJob {
    [CmdletBinding()]
    param()

    Enable-Job 'LogRotateJob' {
        . $CackledaemonConfigLocation

        while ($True) {
            Invoke-LogRotate
            Write-LogDebug ('LogRotateJob sleeping for {0} seconds.' -f $LogCheckTime)
            Start-Sleep -Seconds $LogCheckTime
        }
    }
}

function Disable-LogRotateJob {
    [CmdletBinding()]
    param()

    Disable-Job 'LogRotateJob'
}

#+END_SRC
* Installing Emacs
** Gotchas and Caveats
On a certain level, installing Emacs is a matter of downloading an official zip
file and unpacking it into the system's ~Program Files~ directory. Beyond that,
we can register executables with Windows, set some environment variables,
populate the Start menu, and configure file type associations.

Emacs is fundamentally designed to run on Unix-like systems, meaning that
sometimes the way Windows works violates Emacs' base expectations. This
introduces a few surprises and caveats. Most of these are handled by
Cackledaemon and the details can be found under the relevant sub-headings.
Others, however, are left as an exercise for the reader.

First, ~emacs.exe~ and ~emacsclient.exe~ are written such that they write to
stdout/stderr, but Windows will run programs that try to do this with a
console. To work around this, Emacs ships with ~runemacs.exe~ and
~emacsclientw.exe~, respectively, which wrap the standard entry points in
Windows-specific ones.

Given no other signal, Emacs will open in =/WINDOWS/system32= by default. There
are a number of ways around this:

- Open Emacs inside of a PowerShell or cmd prompt - in this case, Emacs will
  open in the current working directory
- Add a =cd= call to your Emacs config, which will change Emacs' working
  directory whenever it is loaded
- Set the =default-directory= variable in your Emacs config. This will cause
  Emacs to default to opening in that directory when there isn't an associated
  current working directory
- If opening Emacs with a shortcut, the starting directory of that shortcut may
  be set to the desired directory

File associations - that is, what programs Windows will use to try to open
things like org files and so on - can only be made with ~.exe~, ~.bat~, ~.com~
and ~.pif~ files. This means that if you want to have files opened by Emacs
given specific CLI flags via the "Open With..." menu - for example - that you
will either need to write compiled code or batch scripts.

For more details, refer to:

- [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Startup.html][Windows Startup]] in the Emacs manual
- [[https://git.savannah.gnu.org/cgit/emacs.git/tree/nt/][The nt directory]] in Emacs' source tree, particularly ~runemacs.c~ and ~addpm.c~
- [[https://www.emacswiki.org/emacs/MsWindowsInstallation][MS Windows Installation]] in the Emacs wiki
- [[https://www.emacswiki.org/emacs/EmacsMsWindowsIntegration][Emacs MS Windows Integration]] in the Emacs wiki

** Checking if Emacs is Already Installed
One check we can do to see if Emacs is already installed is to see if
~emacs.exe~ is in the expected location given a configured
=$EmacsInstallLocation=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Test-EmacsExe {
    . $CackledaemonConfigLocation

    Test-Path (Join-Path $EmacsInstallLocation 'bin\emacs.exe')
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Test-EmacsExe' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'searches for emacs.exe in the correct location' {
        Mock -ModuleName Cackledaemon Test-Path { $True }

        Test-EmacsExe | Should -Be $True

        Assert-MockCalled -ModuleName Cackledaemon Test-Path `
          -Times 1 `
          -ParameterFilter { $Path -eq "$TestDrive\Program Files\emacs\bin\emacs.exe"}
    }
}

#+END_SRC
** Versions
Emacs exposes versions of the form ~{major).{minor}~. We use a class to
represent these versions and to do basic comparisons between them.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
class Version : IComparable {
    [int]$Major
    [int]$Minor

    Version([int64]$Major, [int64]$Minor) {
        $this.Major = $Major
        $this.Minor = $Minor
    }

    [int]CompareTo([object]$Other) {
        if ($Other -eq $null) {
            return 1
        }

        $Other = [Version]$Other

        if ($this.Major -gt $Other.Major) {
            return 1
        } elseif ($this.Major -lt $Other.Major) {
            return -1
        } elseif ($this.Minor -gt $Other.Minor) {
            return 1
        } elseif ($this.Minor -lt $Other.Minor) {
            return -1
        } else {
            return 0
        }
    }

    [string]ToString() {
        return 'v{0}.{1}' -f $this.Major, $this.Minor
    }
}

function New-Version {
    param(
        [Parameter(Position=0)]
        [int]$Major,
        [Parameter(Position=1)]
        [int]$Minor
    )

    return New-Object Version $Major, $Minor
}

#+END_SRC

The Emacs bin will report versions if installed. We can grep them out, and
otherwise fall back to reporting a null version, which will usually do the right
thing when compared to a =Version= instance.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Get-EmacsExeVersion {
    if (Test-EmacsExe) {
        . $CackledaemonConfigLocation

        $EmacsExe = Join-Path $EmacsInstallLocation 'bin\emacs.exe'
        if ((& $EmacsExe --version)[0] -match '^GNU Emacs (\d+)\.(\d+)$') {
            New-Version $Matches[1] $Matches[2]
        }
    }
}

#+END_SRC

** Official Downloads
Emacs hosts downloads on an Apache webserver running [[https://trisquel.info/][Trisquel Linux]], which I
personally find charming. It turns out that Apache directory listings can be
casually scraped by PowerShell.

It's also worth noting that Cackledaemon only attempts to handle native Windows
x86_64 builds. The first major version of Emacs with such builds is Emacs 25.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
class Download : IComparable {
    [Version]$Version
    [string]$Href

    Download([int64]$Major, [int64]$Minor, [string]$Href) {
        $this.Version = New-Object Version $Major, $Minor
        $this.Href = $Href
    }

    [int]CompareTo([object]$Other) {
        if ($Other -eq $null) {
            return 1
        }

        $Other = [Download]$Other

        return $this.Version.CompareTo($Other.Version)
    }

    [string]ToString() {
        return 'Download($Version={0}; $Href={1})' -f $this.Version, $this.Href
    }
}

function New-Download {
    param(
        [int]$Major,
        [int]$Minor,
        [string]$Href
    )

    New-Object Download $Major, $Minor, $Href
}

function Get-EmacsDownload {
    . $CackledaemonConfigLocation

    return (Invoke-WebRequest $EmacsDownloadsEndpoint).Links | ForEach-Object {
        if ($_.href -match '^emacs-(\d+)/$') {
            $MajorPathPart = $_.href

            if ([int]$Matches[1] -lt 25) {
                return
            }

            (Invoke-WebRequest ($EmacsDownloadsEndpoint + $MajorPathPart)).Links | ForEach-Object {
                 if ($_.href -match '^emacs-(\d+)\.(\d+)-x86_64\.zip$') {
                     $Href = $EmacsDownloadsEndpoint + $MajorPathPart + $_.href
                     return New-Download $Matches[1] $Matches[2] $Href
                 }
            }
        }
    } | Where-Object {$_}
}

function Get-LatestEmacsDownload {
    (Get-EmacsDownload | Measure-Object -Maximum).Maximum
}

#+END_SRC

This test was *way* too difficult to write lmao!

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Get-EmacsDownload' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'fetches emacs downloads' {
        Mock -ModuleName Cackledaemon Invoke-WebRequest {
            if (-not (Test-Path '.\Tapes')) {
                New-Item -Type Directory '.\Tapes'
            }

            $TapePath = Join-Path '.\Tapes' ('{0}.json' -f [uri]::EscapeDataString($Uri))
            $Curl = Get-Command Invoke-WebRequest -CommandType Cmdlet

            if (Test-Path $TapePath) {
                return (Get-Content $TapePath | ConvertFrom-Json)
            } else {
                $Result = & $Curl $Uri
                $Result | ForEach-Object {
                    @{
                        Links=$_.Links
                    }
                } | ConvertTo-Json | Set-Content -Path $TapePath
                return $Result
            }
        }

        $Downloads = Get-EmacsDownload
        $Downloads | Should -Not -Be $null
        $Downloads.Count | Should -BeGreaterOrEqual 1
        $Downloads | ForEach-Object {
            $_.Href | Should -Not -Be $null
            $_.Version | Should -Not -Be $null
        }
    }
}

Describe 'Get-LatestEmacsDownload' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'reports the latest emacs download' {
        Mock -ModuleName Cackledaemon Get-EmacsDownload {
            New-Download 1 3 '1.3'
            New-Download 2 1 '2.1'
            New-Download 2 2 '2.2'
        }

        $LatestDownload = Get-LatestEmacsDownload
        $LatestDownload | Should -Not -Be $null
        $LatestDownload.Href | Should -Not -Be $null
        $LatestDownload.Version | Should -Not -Be $null
        $LatestDownload.Version.Major | Should -Be 2
        $LatestDownload.Version.Minor | Should -Be 2
    }
}

#+END_SRC
** Workspace Management
In order to effectively download, unpack and install Emacs downloads, we need a
directory to store everything. We use a class to represent the components of the
required directory structure and some helper functions to manage setup and teardown.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
class Workspace {
    [System.IO.DirectoryInfo]$Root
    [System.IO.DirectoryInfo]$Archives
    [System.IO.DirectoryInfo]$Installs
    [System.IO.DirectoryInfo]$Backups

    Workspace([string]$Path) {
        $ArchivesPath = Join-Path $Path 'Archives'
        $InstallsPath = Join-Path $Path 'Installs'
        $BackupsPath = Join-Path $Path 'Backups'

        $this.Root = Get-Item $Path
        $this.Archives = Get-Item $ArchivesPath
        $this.Installs = Get-Item $InstallsPath
        $this.Backups = Get-Item $BackupsPath
    }

    [string]GetKey([Version]$Version) {
        return 'emacs-{0}.{1}-x86_64' -f $Version.Major, $Version.Minor
    }

    [string]GetArchivePath([Version]$Version) {
        return Join-Path $this.Archives ('{0}.zip' -f $this.GetKey($Version))
    }

    [boolean]TestArchive([Version]$Version) {
        return Test-Path $this.GetArchivePath($Version)
    }

    [System.IO.FileInfo]GetArchive([Version]$Version) {
        return Get-Item $this.GetArchivePath($Version)
    }

    [string]GetInstallPath([Version]$Version) {
        return Join-Path $this.Installs $this.GetKey($Version)
    }

    [boolean]TestInstall([Version]$Version) {
        return Test-Path $this.GetInstallPath($Version)
    }

    [System.IO.DirectoryInfo]GetInstall([Version]$Version) {
        return Get-Item $this.GetInstallPath($Version)
    }

    Clear() {
        $this.Root = $null
        $this.Archives = $null
        $this.Installs = $null
        $this.Backups = $null
    }
}

function Test-Workspace {
    . $CackledaemonConfigLocation

    Test-Path $WorkspaceDirectory
}

function Get-Workspace {
    . $CackledaemonConfigLocation

    return New-Object Workspace $WorkspaceDirectory
}

function New-Workspace {
    . $CackledaemonConfigLocation

    $ArchivesPath = Join-Path $WorkspaceDirectory 'Archives'
    $InstallsPath = Join-Path $WorkspaceDirectory 'Installs'
    $BackupsPath = Join-Path $WorkspaceDirectory 'Backups'

    New-Item -Type Directory $WorkspaceDirectory | Out-Null

    New-Item -Type Directory $ArchivesPath | Out-Null
    New-Item -Type Directory $InstallsPath | Out-Null
    New-Item -Type Directory $BackupsPath | Out-Null

    return New-Object Workspace $WorkspaceDirectory
}

function Remove-Workspace {
    $Workspace = Get-Workspace

    Remove-Item $Workspace.Root -Recurse

    $Workspace.Clear()
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Workspace' {
    $TestVersion = New-Version 26 3
    $TestKey = 'emacs-26.3-x86_64'
    $TestArchive = "$TestDrive\Cackledaemon\Workspace\Archives\emacs-26.3-x86_64.zip"
    $TestInstall = "$TestDrive\Cackledaemon\Workspace\Installs\emacs-26.3-x86_64"
    $TestWorkspace = $null

    BeforeEach {
        Initialize-TestEnvironment
        $TestWorkspace = New-Workspace
    }

    AfterEach {
        Remove-Workspace
        Restore-StandardEnvironment
    }

    It 'contains the expected directories' {
        'TestDrive:\Cackledaemon\Workspace' | Should -Exist
        'TestDrive:\Cackledaemon\Workspace\Archives' | Should -Exist
        'TestDrive:\Cackledaemon\Workspace\Installs' | Should -Exist
        'TestDrive:\Cackledaemon\Workspace\Backups' | Should -Exist
    }

    It 'can get an existing workspace' {
        Get-Workspace | Should -Not -Be Null
    }

    It 'can generate a key from a version' {
        $TestWorkspace.GetKey($TestVersion) | Should -Be 'emacs-26.3-x86_64'
    }

    It 'can generate an archive path from a version' {
        $TestWorkspace.GetArchivePath($TestVersion) | Should -Be $TestArchive
    }

    Context "when an archive doesn't exist" {
        It 'can test an archive path from a version' {
            $TestWorkspace.TestArchive($TestVersion) | Should -Be $False
        }
    }

    Context 'when an archive exists' {
        BeforeEach {
            New-Item $TestArchive
        }

        It 'can test an archive path from a version' {
            $TestWorkspace.TestArchive($TestVersion) | Should -Be $True
        }

        It 'can get an archive from a version' {
            $TestWorkspace.GetArchive($TestVersion) | Should -Not -Be $null
        }
    }

    It 'can generate an install path from a version' {
        $TestWorkspace.GetInstallPath($TestVersion) | Should -Be $TestInstall
    }

    Context "when an install doesn't exist" {
        It 'can test an install path from a version' {
            $TestWorkspace.TestInstall($TestVersion) | Should -Be $False
        }
    }

    Context 'when an install exists' {
        BeforeEach {
            New-Item -Type Directory $TestInstall
        }

        It 'can test an install path from a version' {
            $TestWorkspace.TestInstall($TestVersion) | Should -Be $True
        }

        It 'can get an install from a version' {
            $TestWorkspace.GetInstall($TestVersion) | Should -Not -Be $null
        }
    }
}
#+END_SRC

** Downloading and Extracting
Given a workspace and an upstream download, we can use =Invoke-WebRequest= to
download the zip files, =Extract-Archive= to unpack them and some filesystem
operations to put them in place.

Note that by default this installs Emacs in ~Program Files~ and so will need
Administrator privileges.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function New-EmacsArchive {
    param(
        [Parameter(Position=0)]
        [Download]$Download
    )

    $Workspace = Get-Workspace

    $Archive = $Workspace.GetArchivePath($Download.Version)

    Invoke-WebRequest `
      -Uri $Download.Href `
      -OutFile $Archive | Out-Null

    return Get-Item $Archive
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'New-EmacsArchive' {
    $TestWorkspace = $null
    $TestDownload = New-Download 26 3 'https:\\test_url'
    $ArchivePath = "$TestDrive\Cackledaemon\Workspace\Archives\emacs-26.3-x86_64.zip"

    BeforeEach {
        Initialize-TestEnvironment
        $TestWorkspace = New-Workspace
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'can download an Emacs archive' {
        Mock -Module Cackledaemon Invoke-WebRequest {
            New-Item $OutFile
        }

        $Archive = New-EmacsArchive $TestDownload

        $Archive | Should -Not -Be $null
        $ArchivePath | Should -Exist
        $Archive.FullName | Should -Be $ArchivePath

        Assert-MockCalled -Module Cackledaemon `
          Invoke-WebRequest `
          -Times 1 `
          -ParameterFilter { $Uri -eq 'https:\\test_url' }
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Export-EmacsArchive {
    param(
        [Parameter(Position=0)]
        [string]$Path
    )

    $Workspace = Get-Workspace

    $Key = [IO.Path]::GetFileNameWithoutExtension($Path)

    $Destination = Join-Path $Workspace.Installs.FullName $Key

    Expand-Archive -Path $Path -DestinationPath $Destination

    return Get-Item $Destination
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Export-EmacsArchive' {
    $TestWorkspace = $null
    $TestDownload = New-Download 26 3 'https:\\test_url'
    $ArchivePath = "$TestDrive\Cackledaemon\Workspace\Archives\emacs-26.3-x86_64.zip"
    $TestArchive = $null
    $InstallPath = "$TestDrive\Cackledaemon\Workspace\Installs\emacs-26.3-x86_64"

    BeforeEach {
        Initialize-TestEnvironment
        $TestWorkspace = New-Workspace
        $TestArchive = New-Item $ArchivePath
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'can extract an Emacs archive' {
        Mock -Module Cackledaemon Expand-Archive {
            New-Item -Type Directory 'TestDrive:\Cackledaemon\Workspace\Installs\emacs-26.3-x86_64' | Out-Null
        }

        $Install = Export-EmacsArchive $TestArchive

        Assert-MockCalled -Module Cackledaemon `
          Expand-Archive `
          -Times 1 `
          -ParameterFilter { $Path -eq $ArchivePath -and $DestinationPath -eq $InstallPath }

        $Install.FullName | Should -Be $InstallPath
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Update-EmacsInstall {
    param(
        [string]$Path
    )


    $Source = Get-Item -ErrorAction Stop $Path

    . $CackledaemonConfigLocation

    $Workspace = Get-Workspace

    $Backup = Join-Path $Workspace.Backups ('emacs-{0}' -f (Get-Date -Format 'yyyyMMddHHmmss'))

    if (Test-Path $EmacsInstallLocation -ErrorAction Stop) {
        Copy-Item $EmacsInstallLocation $Backup -ErrorAction Stop
        Remove-Item -Recurse $EmacsInstallLocation -ErrorAction Stop
    }

    Move-Item $Source $EmacsInstallLocation -ErrorAction Stop
    Remove-Item -Recurse $Backup -ErrorAction SilentlyContinue

    return Get-Item $EmacsInstallLocation
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Update-EmacsInstall' {
    $TestWorkspace = $null
    $InstallPath = "$TestDrive\Cackledaemon\Workspace\Installs\emacs-26.3-x86_64"
    $TestInstall = $null

    BeforeEach {
        Initialize-TestEnvironment
        New-Workspace
        $TestInstall = New-Item -Type Directory 'TestDrive:\Cackledaemon\Workspace\Installs\emacs-26.3-x86_64'
        New-Item 'TestDrive:\Cackledaemon\Workspace\Installs\emacs-26.3-x86_64\NewInstall'
    }

    AfterEach {
        Remove-Item -Recurse 'TestDrive:\Program Files\emacs' -ErrorAction Continue
        Restore-StandardEnvironment
    }

    Context "when there isn't an existing Emacs install" {
        It 'can install Emacs' {
            'TestDrive:\Program Files\emacs' | Should -Not -Exist

            Update-EmacsInstall $InstallPath

            'TestDrive:\Program Files\emacs' | Should -Exist
            'TestDrive:\Program Files\emacs\NewInstall' | Should -Exist
        }
    }

    Context 'when there is an existing Emacs install' {
        It 'can update Emacs' {
            New-Item -Type Directory 'TestDrive:\Program Files\emacs'
            New-Item 'TestDrive:\Program Files\emacs\OldInstall'

            Update-EmacsInstall $InstallPath

            'TestDrive:\Program Files\emacs\NewInstall' | Should -Exist
            'TestDrive:\Program Files\emacs\OldInstall' | Should -Not -Exist
            'TestDrive:\Cackledaemon\Workspace\Backups\*' | Should -Not -Exist
        }
    }
}
#+END_SRC
** Environment Variables
*** PATH Environment Variable
As in Linux and OSX, Windows uses a ~Path~ variable to resolve commands in cmd
and PowerShell. The ~Path~ environment variable can be set for either the
current user or system-wide. We implement the user version because it doesn't
require admin privileges and leaves this as a choice for individual users.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Set-EmacsPathEnvVariable {
    [CmdletBinding()]
    param()

    . $CackledaemonConfigLocation

    $Path = Join-Path $EmacsInstallLocation 'bin'

    $ExistingEmacs = Get-Command 'emacs.exe' -ErrorAction SilentlyContinue

    if ($ExistingEmacs) {
        $ExistingEmacsBinDir = Split-Path $ExistingEmacs.Source -Parent
    }

    if ($ExistingEmacs -and -not ($ExistingEmacsBinDir -eq $Path)) {
        Write-Warning ('An unmanaged Emacs is already installed at {0} - this may cause unexpected behavior.' -f $ExistingEmacsBinDir)
    }

    $PathProperty = (Get-ItemProperty -Path 'HKCU:\Environment' -Name 'Path')
    $PathParts = $PathProperty.Path.Split(';') | Where-Object { $_ }

    $ExistingEmacsPathPart = $PathParts | Where-Object { $_ -eq $Path }

    if ($ExistingEmacsPathPart) {
        Write-Verbose 'Emacs is already in the PATH - no changes necessary.'
    } else {
        $PathProperty.Path += ($Path + ';')

        Set-ItemProperty -Path 'HKCU:\Environment' -Name 'Path' -Value $PathProperty
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Set-EmacsPathEnvVariable' {
    $EmacsPath = $null

    BeforeEach {
        Initialize-TestEnvironment
        $EmacsPath = "$TestDrive\Program Files\emacs\bin"
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when Emacs is not in the PATH' {
        It 'should add Emacs to the PATH' {
            Mock -Module Cackledaemon Get-Command { $False }
            Mock -Module Cackledaemon Get-ItemProperty {
                class FakePathProperty {
                    [string]$Path
                }

                $PathProperty = New-Object FakePathProperty
                $PathProperty.Path = "$TestDrive\Program Files\CoolProgram\bin;$TestDrive\Program Files (x86)\LameProgram;"

                return $PathProperty
            }
            Mock -Module Cackledaemon Set-ItemProperty {
                $Value.Path | Should -Be "$TestDrive\Program Files\CoolProgram\bin;$TestDrive\Program Files (x86)\LameProgram;$TestDrive\Program Files\emacs\bin;"
            }

            Set-EmacsPathEnvVariable -WarningVariable Warnings

            $Warnings | Should -Be $null

            Assert-MockCalled -Module Cackledaemon `
              Get-ItemProperty `
              -Times 1 `
              -ParameterFilter {$Path -eq 'HKCU:\Environment' -and $Name -eq 'Path'}

            Assert-MockCalled -Module Cackledaemon `
              Set-ItemProperty `
              -Times 1 `
              -ParameterFilter { $Path -eq 'HKCU:\Environment' -and $Name -eq 'Path' -and -not($Value -eq $null) }
        }
    }

    Context 'when Emacs is already in the PATH' {
        It 'should do nothing' {
            Mock -Module Cackledaemon Get-Command {
                class FakeCommand {
                   [string]$Source
                }

                $Command = New-Object FakeCommand
                $Command.Source = "$TestDrive\Program Files\emacs\bin\emacs.exe"

                return $Command
            }
            Mock -Module Cackledaemon Get-ItemProperty {
                class FakePathProperty {
                    [string]$Path
                }

                $PathProperty = New-Object FakePathProperty
                $PathProperty.Path = "$TestDrive\Program Files\CoolProgram\bin;$TestDrive\Program Files\emacs\bin;$TestDrive\Program Files (x86)\LameProgram;"

                return $PathProperty
            }

            Mock -Module Cackledaemon Set-ItemProperty {}

            Set-EmacsPathEnvVariable -WarningVariable Warnings

            $Warnings | Should -Be $null

            Assert-MockCalled -Module Cackledaemon `
              Get-ItemProperty `
              -Times 1 `
              -ParameterFilter {$Path -eq 'HKCU:\Environment' -and $Name -eq 'Path'}

            Assert-MockCalled -Module Cackledaemon Set-ItemProperty -Times 0
        }
    }

    Context 'When an unmanged Emacs is in the PATH' {
        It 'should warn but add Emacs to the PATH' {
            Mock -Module Cackledaemon Get-Command {
                class FakeCommand {
                   [string]$Source
                }

                $Command = New-Object FakeCommand
                $Command.Source = "$TestDrive\Program Files (x86)\emacs\bin\emacs.exe"

                return $Command
            }
            Mock -Module Cackledaemon Get-ItemProperty {
                class FakePathProperty {
                    [string]$Path
                }

                $PathProperty = New-Object FakePathProperty
                $PathProperty.Path = "$TestDrive\Program Files\CoolProgram\bin;$TestDrive\Program Files (x86)\emacs\bin;"

                return $PathProperty
            }
            Mock -Module Cackledaemon Set-ItemProperty {
                $Value.Path | Should -Be "$TestDrive\Program Files\CoolProgram\bin;$TestDrive\Program Files (x86)\emacs\bin;$TestDrive\Program Files\emacs\bin;"
            }

            Set-EmacsPathEnvVariable -WarningVariable Warnings 3> $null

            $Warnings | Should -Not -Be $null
            $Warnings.Count | Should -Be 1
            $Warnings[0].ToString() | Should -Be "An unmanaged Emacs is already installed at $TestDrive\Program Files (x86)\emacs\bin - this may cause unexpected behavior."

            Assert-MockCalled -Module Cackledaemon `
              Get-ItemProperty `
              -Times 1 `
              -ParameterFilter {$Path -eq 'HKCU:\Environment' -and $Name -eq 'Path'}

            Assert-MockCalled -Module Cackledaemon `
              Set-ItemProperty `
              -Times 1 `
              -ParameterFilter { $Path -eq 'HKCU:\Environment' -and $Name -eq 'Path' -and -not($Value -eq $null) }
        }
    }
}
#+END_SRC
*** HOME Environment Variable
Emacs generally tries to find its init files in =$HOME/.emacs.d= but Windows
doesn't have a 1:1 concept of a home directory and the environment variable is
typically not set. Emacs for historical reasons defaults to using =$Env:AppDir=,
but in practice most people want to set =$Env:HOME= to =$Env:UserProfile=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Set-HomeEnvVariable {
    . $CackledaemonConfigLocation

    Set-ItemProperty -Path 'HKCU:\Environment' -Name 'HOME' -Value $HomeDirectory
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Set-HomeEnvVariable' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'should set the HOME environment variable' {
        Mock -Module Cackledaemon Set-ItemProperty {}

        Set-HomeEnvVariable

        Assert-MockCalled -Module Cackledaemon Set-ItemProperty -Times 1 -ParameterFilter { $Path -eq 'HKCU:\Environment' -and $Name -eq 'HOME' -and $Value -eq "$TestDrive\UserProfile" }
    }
}
#+END_SRC
** App Paths Registry Keys
Windows, in addition to the concept of a user ~Path~, also has the concept of
[[https://docs.microsoft.com/en-us/windows/win32/shell/app-registration][app paths]]. These paths are used so that tools like the run command - and
anything using [[https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecuteexa][the ShellExecuteEx API]] - can find the associated programs.

The relevant registry entries are in ~HKEY_LOCAL_MACHINE~ and need to be set
as an administrator.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Set-EmacsAppPathRegistryKeys {
    . $CackledaemonConfigLocation


    @('emacs.exe', 'runemacs.exe', 'emacsclient.exe', 'emacsclientw.exe') | ForEach-Object {
        $RegistryPath = Join-Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths' $_
        $BinPath = Join-Path $EmacsInstallLocation "bin\$_"

        if (Test-Path $BinPath) {
            Set-Item -Path $RegistryPath -Value $BinPath
            Set-ItemProperty -Path $RegistryPath -Name Path -Value $Path
        } else {
            Write-Error -Message ("{0} doesn't exist - refusing to write this to the registry." -f $BinPath) `
              -Category ObjectNotFound `
              -CategoryActivity 'Set-EmacsAppPathRegistryKeys' `
              -CategoryReason 'ItemNotFoundException'`
              -CategoryTargetName $BinPath `
              -CategoryTargetType 'string'
        }

    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Set-EmacsAppPathRegistryKeys' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when Emacs is installed' {
        BeforeEach {
            New-Item -Type Directory "$TestDrive\Program Files\emacs"
            New-Item -Type Directory "$TestDrive\Program Files\emacs\bin"
            New-Item "$TestDrive\Program Files\emacs\bin\emacs.exe"
            New-Item "$TestDrive\Program Files\emacs\bin\runemacs.exe"
            New-Item "$TestDrive\Program Files\emacs\bin\emacsclient.exe"
            New-Item "$TestDrive\Program Files\emacs\bin\emacsclientw.exe"
        }

        AfterEach {
            Remove-Item -Recurse "$TestDrive\Program Files\emacs"
        }

        It 'sets the Emacs app path registry keys' {
            Mock -Module Cackledaemon Set-Item {}
            Mock -Module Cackledaemon Set-ItemProperty {}

            Set-EmacsAppPathRegistryKeys

            Assert-MockCalled -Module Cackledaemon Set-Item -Times 4
            Assert-MockCalled -Module Cackledaemon Set-ItemProperty -Times 4
        }
    }

    Context "when Emacs isn't installed" {
        It "doesn't set any registry keys" {
            Mock -Module Cackledaemon Set-Item {}
            Mock -Module Cackledaemon Set-ItemProperty {}

            Set-EmacsAppPathRegistryKeys 2> $null

            Assert-MockCalled -Module Cackledaemon Set-Item -Times 0
            Assert-MockCalled -Module Cackledaemon Set-ItemProperty -Times 0

            (0..3) | ForEach-Object {
                $Error[$_] | Should -Match "doesn't exist - refusing to write this to the registry."
            }
        }
    }
}

#+END_SRC
** Start Menu and Shortcuts
*** Start Menu Items
Emacs's ~addpm.exe~ creates a shortcut to ~emacs.exe~ in a sub-folder called
"Gnu Emacs". The default Start menu path follows this convention.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Get-StartMenuItems {
    . $CackledaemonConfigLocation

    Get-ChildItem -Path $StartMenuPath -ErrorAction SilentlyContinue | ForEach-Object {
        Get-Item $_.FullName
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Get-StartMenuItems' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when there are already start menu items' {
        $TestShortcut = $null
        BeforeEach {
            New-Item -Type Directory 'TestDrive:\AppData\Microsoft\Windows\Start Menu\Programs\Gnu Emacs'
            $TestShortcut = New-Item 'TestDrive:\AppData\Microsoft\Windows\Start Menu\Programs\Gnu Emacs\Test.lnk'
        }

        AfterEach {
            Remove-Item -Recurse 'TestDrive:\AppData\Microsoft\Windows\Start Menu\Programs\Gnu Emacs'
        }

        It 'should get start menu items' {
            $Items = Get-StartMenuItems

            $Items.Count | Should -Be 1

            $Items | ForEach-Object { $_.FullName } | Should -Contain $TestShortcut.FullName
        }
    }

    Context "when there isn't a start menu folder" {
        It 'should yield zero items' {
            $Items = Get-StartMenuItems

            $Items.Count | Should -Be 0
        }
    }
}

#+END_SRC
*** Creating Shortcuts
We can create a shortcut by using [[https://docs.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal][COM]] to interact with [[https://en.wikipedia.org/wiki/Windows_Script_Host][Windows Script Host.]]

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Get-WShell {
    if (-not $WShell) {
        $Global:WShell = New-Object -comObject WScript.Shell
    }

    return $WShell
}

function Set-Shortcut {
    param(
        [string]$ShortcutPath,
        [string]$TargetPath,
        [string[]]$ArgumentList = @(),
        [string]$WorkingDirectory = $Env:UserProfile,
        [string]$Description
    )

    $Shell = Get-WShell

    $Arguments = ($ArgumentList | ForEach-Object {
        if ($_ -match '[" ]') {
            return ('"{0}"' -f ($_ -replace '"', '\"'))
        } else {
            return ($_ -replace '([,;=\W])', '^$1')
        }
    }) -join ' '

    $Shortcut = $Shell.CreateShortcut($ShortcutPath)
    $Shortcut.TargetPath = $TargetPath
    $Shortcut.Arguments = $Arguments
    $Shortcut.WorkingDirectory = $WorkingDirectory

    if ($Description) {
        $Shortcut.Description = $Description
    }

    $Shortcut.Save()
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Get-WShell' {
    It 'returns a singleton WShell' {
        $Shell = Get-WShell

        $Shell | Should -Not -Be $null

        Get-Wshell | Should -BeExactly $Shell
    }
}

Describe 'Set-Shortcut' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'should create shortcuts' {
        Mock -Module Cackledaemon Get-WShell {
            class FakeShell {
                [FakeShortcut]CreateShortcut([string]$Path) {
                    class FakeShortcut {
                        [string]$ShortcutPath
                        [string]$TargetPath
                        [string[]]$Arguments
                        [string]$WorkingDirectory
                        [string]$Description

                        Save() {
                            $this.ShortcutPath | Should -Be 'shortcut path'
                            $this.TargetPath | Should -Be 'target path'
                            $this.Arguments | Should -Be '"foo bar" "\"baz\"" ^;quux^,'
                            $this.Description | Should -Be 'description'
                        }
                    }

                    $Shortcut = New-Object FakeShortcut
                    $Shortcut.ShortcutPath = $Path
                    return $Shortcut
                }
            }

            return New-Object FakeShell
        }

        Set-Shortcut -ShortcutPath 'shortcut path' -TargetPath 'target path' -Description 'description' -ArgumentList @('foo bar', '"baz"', ';quux,')

        Assert-MockCalled -Module Cackledaemon Get-WShell -Times 1
    }

}
#+END_SRC
*** Installation
Given a shortcuts config, we can "install" them by comparing the shortcuts in
the directory with the ones that are configured, cleaning up the ones we don't
want and setting the rest.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Install-Shortcuts {
    . $CackledaemonConfigLocation

    $Config = Get-ShortcutsConfig
    $CurrentItems = Get-StartMenuItems
    $DesiredShortcutPaths = $Config | ForEach-Object {
        Join-Path $StartMenuPath ($_.ShortcutName + ".lnk")
    }

    $CurrentItems | Where-Object {
        -not $DesiredShortcutPaths.Contains($_.FullName)
    } | ForEach-Object {
        Remove-Item $_
    }

    $Config | ForEach-Object {
        Set-Shortcut `
          -ShortcutPath (Join-Path $StartMenuPath ($_.ShortcutName + ".lnk")) `
          -TargetPath (Join-Path "$EmacsInstallLocation\bin" $_.EmacsBinaryName) `
          -ArgumentList $_.ArgumentList `
          -Description $_.Description
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Install-Shortcuts' {
    BeforeEach {
        Initialize-TestEnvironment
        New-Item -Type Directory 'TestDrive:\AppData\Microsoft\Windows\Start Menu\Programs\Gnu Emacs'
        New-Item 'TestDrive:\AppData\Microsoft\Windows\Start Menu\Programs\Gnu Emacs\RemoveMe.lnk'
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'installs shortcuts' {
        Install-Shortcuts

        'TestDrive:\AppData\Microsoft\Windows\Start Menu\Programs\Gnu Emacs\RemoveMe.lnk' | Should -Not -Exist
        'TestDrive:\AppData\Microsoft\Windows\Start Menu\Programs\Gnu Emacs\EmacsClient.lnk' | Should -Exist
    }
}

#+END_SRC
** File Type Associations
File type associations in Windows are [[https://twitter.com/jfhbrook/status/1245917952316039169]["complicated"]] and the documentation for
them isn't great.

At the user level, Explorer manages a bunch of registry settings that encode
which applications a user has associated with a file type via the "Open With"
dialogs, as well as what they've picked as the default for opening that file.
The structure of these registry settings is complicated and research has
indicated that Microsoft would just as soon not have programs messing with these
settings.

However, on the system level, the batch commands [[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/ftype][ftype]] and [[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/assoc][assoc]] can be used to
set file type associations. These associations can be used to set defaults for
Explore for when a user hasn't interacted with them. ~assoc~ associates an
extension with a human-readable file type, and ~ftype~ connects that file type
with a command template.

This means that while the config for this is managed in
a single table, Windows actually manages these in two separate collections - one
for each command. The upshot is that it's possible to have a file type
registered with ~assoc~ but not in ~ftype~, and vice versa. In practice,
however, having one of these fields as null isn't very useful, so we don't
support it.

Additionally, while both of these commands support unsetting a key, we never
attempt to do any cleanup since it's assumed that an unused association is
non-harmful, while removing a used association on accident is very bad.

Note that these commands must be ran with Administrator privileges.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Install-FileTypeAssociations {
    Get-FileTypeAssociationsConfig | ForEach-Object {
        cmd /c assoc ("{0}={1}" -f $_.Extension, $_.FileType)
        cmd /c ftype ("{0}={1}" -f $_.FileType, $_.Command)
    }
}

#+END_SRC
** Putting It All Together
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Install-EmacsUserEnvironment {
    $ErrorActionPreference = 'Stop'

    Write-Progress -Id 3 -Activity 'Setting up the Emacs user environment' -CurrentOperation "Updating the user's `$Path variable..." -PercentComplete 0
    Write-LogHost "Updating the user's `$Path variable..."

    Set-EmacsPathEnvVariable

    Write-Progress -Id 3 -Activity 'Setting up the Emacs user environment' -CurrentOperation "Setting the user's `$HOME variable..." -PercentComplete 33
    Write-LogHost "Setting the user's `$HOME variable..."

    Set-HomeEnvVariable

    Write-Progress -Id 3 -Activity 'Setting up the Emacs user environment' -CurrentOperation "Installing shortcuts..." -PercentComplete 67
    Write-LogHost "Installing shortcuts..."

    Install-Shortcuts

    Write-Progress -Id 3 -Activity 'Setting up the Emacs user environment' -Completed
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Install-Emacs {
    $ErrorActionPreference = 'Stop'

    Write-Progress -Id 1 -Activity 'Installing Emacs' -CurrentOperation 'Loading Cackledaemon configuration...' -PercentComplete 0
    Write-LogVerbose 'Loading Cackledaemon configuration...'

    . $CackledaemonConfigLocation

    if (Test-Workspace) {
        $Workspace = Get-Workspace
    } else {
        Write-Progress -Id 1 -Activity 'Installing Emacs' -CurrentOperation 'Creating workspace...' -PercentComplete 14
        Write-LogVerbose 'Creating new workspace...'

        $Workspace = New-Workspace
    }

    Write-Progress -Id 1 -Activity 'Installing Emacs' -CurrentOperation 'Checking the Emacs website for the latest available download...' -PercentComplete 29
    Write-LogHost 'Checking the Emacs website for the latest available download...'

    $LatestDownload = Get-LatestEmacsDownload

    Write-LogVerbose ('Version {0} is the latest version of Emacs available for install' -f $LatestDownload.Version)

    $ShouldInstall = $False

    Write-Progress -Id 1 -Activity 'Installing Emacs' -CurrentOperation 'Checking if Emacs needs to be installed or updated...' -PercentComplete 43
    Write-Progress -ParentId 1 -Id 2 -Activity 'Checking the currently installed Emacs version' -CurrentOperation "Looking for an Emacs install in $EmacsInstallLocation..." -PercentComplete 0
    if (Test-EmacsExe) {
        Write-Progress -ParentId 1 -Id 2 -Activity 'Checking the currently installed Emacs version' -CurrentOperation 'Running "Emacs --version"...' -PercentComplete 33

        $InstalledVersion = Get-EmacsExeVersion

        Write-LogVerbose ('Version {0} of Emacs is installed' -f $InstalledVersion)

        Write-Progress -ParentId 1 -Id 2 -Activity 'Checking the currently installed Emacs version' -CurrentOperation 'Comparing versions...' -PercentComplete 57
        if ($LatestDownload.Version -gt $InstalledVersion) {
            Write-LogVerbose ('Upstream Emacs version {0} is newer than installed Emacs version {1}' -f $LatestDownload.Version, $InstalledVersion)
            $ShouldInstall = $True
        } else {
            Write-LogVerbose ('Upstream Emacs version {0} is no newer than installed Emacs version {1}' -f $LatestDownload.Version, $InstalledVersion)
        }
    } else {
        Write-LogVerbose 'No version of Emacs is installed'
        $ShouldInstall = $True
    }

    Write-Progress -ParentId 1 -Id 2 -Activity 'Checking the currently installed Emacs version' -Completed

    if (-not $ShouldInstall) {
        Write-Progress -Id 1 -Activity 'Installing Emacs' -Completed
        Write-LogHost 'Emacs is currently installed and at the latest available version.'
    } else {
        $TargetVersion = $LatestDownload.Version

        if ($Workspace.TestInstall($TargetVersion)) {
            Write-LogVerbose "Emacs has already been downloaded and unpacked for version $TargetVersion"
            $Install = $Workspace.GetInstall($TargetVersion)
        } else {
            if ($Workspace.TestArchive($TargetVersion)) {
                Write-LogVerbose "Eamcs has already been downloaded (but not unpacked) for version $TargetVersion"
                $Archive = $Workspace.GetArchive($TargetVersion);
            } else {
                Write-Progress -Id 1 -Activity 'Installing Emacs' -CurrentOperation "Downloading Emacs version $TargetVersion..." -PercentComplete 71
                Write-LogHost "Downloading Emacs version $TargetVersion..."

                $Archive = New-EmacsArchive $LatestDownload
            }
            Write-Progress -Id 1 -Activity 'Installing Emacs' -CurrentOperation "Unpacking Emacs version $TargetVersion..." -PercentComplete 86
            Write-LogHost "Unpacking Emacs version $TargetVersion..."

            $Install = Export-EmacsArchive $Archive
        }


        Write-Progress -Id 1 -Activity 'Installing Emacs' -CurrentOperation 'Executing Administrator commands...' -PercentComplete 60
        Write-LogHost "Executing Administrator commands..."

        Start-Process -Wait powershell.exe -Verb RunAs -ArgumentList '-Command', "& {
            `$ErrorActionPreference = 'Stop'
            Import-Module Cackledaemon

            Write-Progress -Activity 'Installing Emacs' -CurrentOperation 'Moving files to $EmacsInstallLocation...' -PercentComplete 0

            Write-LogHost 'Moving files to $EmacsInstallLocation...'
            Update-EmacsInstall -Path $Install

            Write-Progress -Activity 'Installing Emacs' -CurrentOperation 'Setting App Path registry keys...' -PercentComplete 1

            Write-LogHost 'Setting App Path registry keys...'
            Set-EmacsAppPathRegistryKeys

            Write-Progress -Activity 'Installing Emacs' -CurrentOperation 'Setting file type associations...' -PercentComplete 2

            Write-LogHost 'Setting file type associations...'
            Install-FileTypeAssociations

            Write-Progress -Activity 'Installing Emacs' -Completed
        }"

        Write-Progress -Id 1 -Activity 'Installing Emacs' -Completed
        Write-LogHost "Emacs $TargetVersion is installed and ready to rock!"
    }
}

#+END_SRC
* Daemon Management
** TCP Server File
Typically ~emacsclient~ communicates with the daemon using unix sockets, but
Windows doesn't support them. Therefore, Emacs [[https://www.gnu.org/software/emacs/manual/html_node/emacs/TCP-Emacs-server.html][runs its server over TCP]] and
~emacsclient.exe~ looks for a file that advertises the port. This file by
default needs to exist in =~/.emacs.d/server/=. If the =~/.emacs.d= folder
doesn't exist for whichever reason - for instance if you're using a =~/.emacs=
file and don't have a =~/.emacs.d=, which is possible if you're using [[https://github.com/plexus/chemacs][Chemacs]] -
then the Emacs daemon will fail to create that file and ~emacsclient.exe~ will
be unable to connect.

Working around this involves setting a variable inside your Emacs config, but
generally speaking you should just ensure that =~/.emacs.d= exists where it's
expected.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Test-ServerFileDirectory {
    . $CackledaemonConfigLocation

    Test-Path $ServerFileDirectory
}

function New-ServerFileDirectory {
    . $CackledaemonConfigLocation

    New-Item -Type Directory $ServerFileDirectory
}

function Clear-ServerFileDirectory {
    . $CackledaemonConfigLocation

    Get-ChildItem $ServerFileDirectory | ForEach-Object {
        Remove-Item $_.FullName
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'New-ServerFileDirectory' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'creates a new server file directory' {
        New-ServerFileDirectory

        'TestDrive:\UserProfile\.emacs.d\server' | Should -Exist
    }
}

Describe 'Test-ServerFileDirectory' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when there is not a server file directory' {
        It 'tests for a server file directory' {
            Test-ServerFileDirectory | Should -Be $False
        }
    }

    Context 'when there is a server file directory' {
        BeforeEach {
            New-ServerFileDirectory
        }
        It 'tests for a server file directory' {
            Test-ServerFileDirectory | Should -Be $True
        }
    }
}

Describe 'Clear-ServerFileDirectory' {
    BeforeEach {
        Initialize-TestEnvironment
        New-ServerFileDirectory
        New-Item 'TestDrive:\UserProfile\.emacs.d\server\TestFile'
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'should clear the server file directory' {
        Clear-ServerFileDirectory
        'TestDrive:\UserProfile\.emacs.d\server' | Should -Exist
        'TestDrive:\UserProfile\.emacs.d\server\TestFile' | Should -Not -Exist
    }
}

#+END_SRC
** Process State Serialization
In order to do basic monitoring of the Emacs daemon, we serialize the process
object to and from a JSON file inside the working directory. We only need to
save the ID, but storing the entire process object is easier.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Write-ProcessToPidFile {
    param([System.Diagnostics.Process]$Process)

    . $CackledaemonConfigLocation

    ($Process).Id | ConvertTo-Json | Out-File $PidFile
}

function Get-ProcessFromPidFile {
    . $CackledaemonConfigLocation

    if (-not (Test-Path $PidFile)) {
        return $null
    }

    $Id = (Get-Content $PidFile | ConvertFrom-Json)

    $Process = Get-Process -Id $Id -ErrorAction SilentlyContinue

    if (-not $Process) {
        Remove-Item $PidFile
    }

    return $Process
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Write-ProcessToPidFile' {
    $TestProcess = $null
    BeforeEach {
        Initialize-TestEnvironment
        $TestProcess = (Get-Process)[0]
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    It 'writes a process ID to the PID file' {
        Write-ProcessToPidFile $TestProcess
        'TestDrive:\Cackledaemon\DaemonPidFile.json' | Should -Exist
        'TestDrive:\Cackledaemon\DaemonPidFile.json' | Should -FileContentMatch $TestProcess.Id
    }
}

Describe 'Get-ProcessFromPidFile' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when the PID file is current' {
        $TestProcess = $null

        BeforeEach {
            $TestProcess = (Get-Process)[0]

            Write-ProcessToPidFile $TestProcess
        }

        It 'reads a process ID from the PID file' {
            $Process = Get-ProcessFromPidFile
            $Process.Id | Should -Be $TestProcess.Id
        }
    }

    Context 'when the PID file is stale' {
        BeforeEach {
            Set-Content -Path 'TestDrive:\Cackledaemon\DaemonPidFile.json' -Value '123456789'
            Get-Process -Id 123456789 -ErrorAction SilentlyContinue | Should -Be $null
        }

        It 'removes the PID file and returns null' {
            $Process = Get-ProcessFromPidFile
            $Process | Should -Be $null
            'TestDrive:\Cackledaemon\DaemonPidFile.json' | Should -Not -Exist
        }
    }

    Context 'when there is no PID file' {
        It 'returns null' {
            $Process = Get-ProcessFromPidFile
            $Process | Should -Be $null
        }
    }
}

#+END_SRC
** Checking For Existing Daemons
It would probably be bad to try to start an Emacs daemon if one is already
running.

if an Emacs daemon is being managed, then retrieving the process state should be
successful and we can simply check to make sure that =Get-EmacsProcessFromPidFile=
returns a non-=$null= value. However, it's also possible to start the Emacs
daemon out-of-band, in which case we probably don't want to get involved either.
To check for this, we use [[https://docs.microsoft.com/en-us/powershell/module/cimcmdlets/get-ciminstance?view=powershell-7][CIM]] to find emacs processes and then check to see if
any of them have ~--daemon~ in their command line args. We intentionally punt on
the edge case of searching for emacs instances *not* started with the ~--daemon~
but which have called =(run-server)=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Get-UnmanagedEmacsDaemon () {
    $ManagedProcess = Get-ProcessFromPidFile
    return Get-CimInstance -Query "
        SELECT
          ,*
        FROM Win32_Process
        WHERE
          Name = 'emacs.exe' OR Name = 'runemacs.exe'
    " | Where-Object {
        $_.CommandLine.Contains("--daemon")
    } | ForEach-Object {
        Get-Process -Id ($_.ProcessId)
    } | Where-Object { -not ($_.Id -eq $ManagedProcess.Id) }
}

#+END_SRC
** Start the Emacs Daemon
This function launches the Emacs daemon (if it's not running already) with
sensible parameters and stores process info so we can do basic monitoring.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Start-EmacsDaemon {
    [CmdletBinding()]
    param ([switch]$Wait)

    . $CackledaemonConfigLocation

    $Process = Get-ProcessFromPidFile

    if ($Process) {
        Write-LogError `
          -Message 'The Emacs daemon is already running and being managed.' `
          -Category ResourceExists `
          -CategoryActivity 'Start-EmacsDaemon' `
          -CategoryReason ManagedResourceExistsException

    } elseif (Get-UnmanagedEmacsDaemon) {
        Write-LogError `
          -Message 'An unmanaged Emacs daemon is running.' `
          -Category ResourceExists `
          -CategoryActivity 'Start-EmacsDaemon' `
          -CategoryReason UnmanagedResourceExistsException
    } else {
        Write-LogVerbose 'Starting the Emacs daemon...'

        $Process = Start-Process `
          -FilePath 'emacs.exe' `
          -ArgumentList '--daemon' `
          -NoNewWindow `
          -RedirectStandardOut $EmacsStdOutLogFile `
          -RedirectStandardError $EmacsStdErrLogFile `
          -PassThru

        Write-ProcessToPidFile $Process

        if ($Wait) {
            Write-Verbose 'Waiting for Emacs daemon to exit...'
            $Process = Wait-Process -Id $Process.Id
        }

        Write-Verbose 'Done.'

        return $Process
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Start-EmacsDaemon' {

    Context 'when Emacs is not running and -Wait is false' {
        BeforeEach {
            Initialize-TestEnvironment
        }

        AfterEach {
            Restore-StandardEnvironment
        }

        It 'starts Emacs in the background' {
            Mock -Module Cackledaemon Get-ProcessFromPidFile { $null }
            Mock -Module Cackledaemon Get-UnmanagedEmacsDaemon { $null }
            Mock -Module Cackledaemon Start-Process { (Get-Process)[0] }
            Mock -Module Cackledaemon Write-ProcessToPidFile {}
            Mock -Module Cackledaemon Wait-Process {}

            Start-EmacsDaemon

            Assert-MockCalled -Module Cackledaemon Get-ProcessFromPidFile -Times 1
            Assert-MockCalled -Module Cackledaemon Get-UnmanagedEmacsDaemon -Times 1
            Assert-MockCalled -Module Cackledaemon Start-Process -Times 1
            Assert-MockCalled -Module Cackledaemon Write-ProcessToPidFile -Times 1
            Assert-MockCalled -Module Cackledaemon Wait-Process -Times 0
        }
    }

    Context 'when Emacs is not running and -Wait is true' {
        BeforeEach {
            Initialize-TestEnvironment
        }

        AfterEach {
            Restore-StandardEnvironment
        }

        It 'starts Emacs and then waits' {
            Mock -Module Cackledaemon Get-ProcessFromPidFile { $null }
            Mock -Module Cackledaemon Get-UnmanagedEmacsDaemon { $null }
            Mock -Module Cackledaemon Start-Process { (Get-Process)[0] }
            Mock -Module Cackledaemon Write-ProcessToPidFile { $null }
            Mock -Module Cackledaemon Wait-Process { (Get-Process)[0] }

            Start-EmacsDaemon -Wait

            Assert-MockCalled -Module Cackledaemon Get-ProcessFromPidFile -Times 1
            Assert-MockCalled -Module Cackledaemon Get-UnmanagedEmacsDaemon -Times 1
            Assert-MockCalled -Module Cackledaemon Start-Process -Times 1
            Assert-MockCalled -Module Cackledaemon Write-ProcessToPidFile -Times 1
            Assert-MockCalled -Module Cackledaemon Wait-Process -Times 1
        }
    }

    Context 'when Emacs is running' {
        BeforeEach {
            Initialize-TestEnvironment
        }

        AfterEach {
            Restore-StandardEnvironment
        }

        It 'logs an error and exits' {
            Mock -Module Cackledaemon Get-ProcessFromPidFile { (Get-Process)[0] }
            Mock -Module Cackledaemon Get-UnmanagedEmacsDaemon {}
            Mock -Module Cackledaemon Start-Process {}
            Mock -Module Cackledaemon Write-ProcessToPidFile {}
            Mock -Module Cackledaemon Wait-Process {}

            Start-EmacsDaemon 2> $null

            Assert-MockCalled -Module Cackledaemon Get-ProcessFromPidFile -Times 1
            Assert-MockCalled -Module Cackledaemon Get-UnmanagedEmacsDaemon -Times 0
            Assert-MockCalled -Module Cackledaemon Start-Process -Times 0
            Assert-MockCalled -Module Cackledaemon Write-ProcessToPidFile -Times 0
            Assert-MockCalled -Module Cackledaemon Wait-Process -Times 0

            $Error[0].ToString() | Should -Be 'The Emacs daemon is already running and being managed.'
        }
    }

    Context 'when an unmanaged Emacs is running' {
        BeforeEach {
            Initialize-TestEnvironment
        }

        AfterEach {
            Restore-StandardEnvironment
        }

        It 'logs an error and exits' {
            Mock -Module Cackledaemon Get-ProcessFromPidFile { $null }
            Mock -Module Cackledaemon Get-UnmanagedEmacsDaemon { (Get-Process)[0] }
            Mock -Module Cackledaemon Start-Process {}
            Mock -Module Cackledaemon Write-ProcessToPidFile {}
            Mock -Module Cackledaemon Wait-Process {}

            Start-EmacsDaemon 2> $null

            Assert-MockCalled -Module Cackledaemon Get-ProcessFromPidFile -Times 1
            Assert-MockCalled -Module Cackledaemon Get-UnmanagedEmacsDaemon -Times 1
            Assert-MockCalled -Module Cackledaemon Start-Process -Times 0
            Assert-MockCalled -Module Cackledaemon Write-ProcessToPidFile -Times 0
            Assert-MockCalled -Module Cackledaemon Wait-Process -Times 0

            $Error[0].ToString() | Should -Be 'An unmanaged Emacs daemon is running.'
        }
    }
}

#+END_SRC
** Get the Emacs Daemon
We actually already have this, its name just isn't very ergonomic. This wrapper
just adds cmdlet bindings so that -ErrorAction works.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Get-EmacsDaemon {
    [CmdletBinding()]
    param()

    Get-EmacsProcessFromPidFile
}

#+END_SRC
** Stop the Emacs Daemon
Stopping the process is simply a matter of retrieving the process state from
disk and attempting to stop the process.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Stop-EmacsDaemon {
    [CmdletBinding()]
    param()

    $Process = Get-ProcessFromPidFile

    if (-not $Process) {
        Write-LogError `
          -Message "A managed Emacs daemon isn't running and can not be stopped!" `
          -Category ResourceUnavailable `
          -CategoryActivity 'Stop-EmacsDaemon' `
          -CategoryReason ManagedResourceUnavailableException
    } else {
        Write-LogVerbose 'Stopping the Emacs daemon...'

        Stop-Process -InputObject $Process

        Write-ProcessToPidFile $null

        Write-LogVerbose 'Done.'
    }
}

#+END_SRC

#+BEGIN_SRC powershell :tangle ./Cackledaemon.Tests.ps1
Describe 'Stop-EmacsDaemon' {
    BeforeEach {
        Initialize-TestEnvironment
    }

    AfterEach {
        Restore-StandardEnvironment
    }

    Context 'when Emacs is running' {
        It 'stops Emacs' {
            Mock -Module Cackledaemon Get-ProcessFromPidFile { (Get-Process)[0] }
            Mock -Module Cackledaemon Stop-Process {}
            Mock -Module Cackledaemon Write-ProcessToPidFile {}

            Stop-EmacsDaemon

            Assert-MockCalled -Module Cackledaemon Get-ProcessFromPidFile -Times 1
            Assert-MockCalled -Module Cackledaemon Stop-Process -Times 1
            Assert-MockCalled -Module Cackledaemon Write-ProcessToPidFile -Times 1 -ParameterFilter { $Process -eq $null }
        }
    }

    Context 'when Emacs is not running' {
        It 'exits with an error' {
            Mock -Module Cackledaemon Get-ProcessFromPidFile { $null }
            Mock -Module Cackledaemon Stop-Process {}
            Mock -Module Cackledaemon Write-ProcessToPidFile {}

            Stop-EmacsDaemon 2> $null

            Assert-MockCalled -Module Cackledaemon Get-ProcessFromPidFile -Times 1
            Assert-MockCalled -Module Cackledaemon Stop-Process -Times 0
            Assert-MockCalled -Module Cackledaemon Write-ProcessToPidFile -Times 0

            $Error[0].ToString() | Should -Be "A managed Emacs daemon isn't running and can not be stopped!"
        }
    }
}

#+END_SRC
** Restart the Emacs Daemon
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Restart-EmacsDaemon {
    [CmdletBinding()]
    param()

    try {
        Stop-EmacsDaemon -ErrorAction Stop
    } catch {
        Write-LogWarning 'Attempting to start the Emacs daemon even though stopping it failed'
    }

    Start-EmacsDaemon
}

#+END_SRC
* Desktop Applet
Cackledaemon uses Windows Forms to create a desktop tray applet.

Note that there are a few things that may seem a little odd but are necessary:

- Using global variables. This is because code running outside of this
  function's scope, including certain kinds of callbacks, need access to these
  properties.
- Creating and showing a Form even though nothing is being drawn to it. If the
  form doesn't exist when we try to generate the context menu, very strange
  things happen.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
Add-Type -AssemblyName System.Windows.Forms

function Invoke-Applet {
    [CmdletBinding()]
    param()

    # The parent Form

    $Global:AppletForm = New-Object System.Windows.Forms.Form
    $AppletForm.Visible = $False
    $AppletForm.WindowState = "minimized"
    $AppletForm.ShowInTaskbar = $False

    # The NotifyIcon

    $Global:AppletIcon = New-Object System.Windows.Forms.NotifyIcon
    $AppletIcon.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon(
        (Get-Command 'emacs.exe').Path
    )
    $AppletIcon.Visible = $True

    # Notify the user if something fails

    function Start-InstrumentedBlock {
        param(
            [Parameter(Position=0)]
            [string]$Message,

            [Parameter(Position=1)]
            [ScriptBlock]$ScriptBlock,

            [System.Windows.Forms.ToolTipIcon]$Icon = [System.Windows.Forms.ToolTipIcon]::Warning
        )

        try {
            Invoke-Command -ScriptBlock $ScriptBlock
        } catch {
            Try {
                . $CackledaemonConfigLocation
            } Catch {
                Write-Warning 'Unable to load configuration! Using default notify timeout.'
                $NotifyTimeout = 5000
            }

            Write-LogError -Message $_.Exception.Message `
              -Exception $_.Exception `
              -Category $_.CategoryInfo.Category `
              -CategoryActivity $_.CategoryInfo.Activity `
              -CategoryReason $_.CategoryInfo.Reason `
              -CategoryTargetName $_.CategoryInfo.TargetName `
              -CategoryTargetType $_.CategoryInfo.TargetType

            $AppletIcon.BalloonTipIcon = $Icon
            $AppletIcon.BalloonTipTitle = $Message
            $AppletIcon.BalloonTipText = $_.Exception
            $AppletIcon.ShowBalloonTip($NotifyTimeout)
        }

    }

    # The right-click menu

    $ContextMenu = New-Object System.Windows.Forms.ContextMenu
    $AppletIcon.ContextMenu = $ContextMenu

    # Status items

    $DaemonStatusItem = New-Object System.Windows.Forms.MenuItem
    $DaemonStatusItem.Index = 0
    $DaemonStatusItem.Text = '[???] Emacs Daemon'
    $ContextMenu.MenuItems.Add($DaemonStatusItem) | Out-Null

    $LogRotateStatusItem = New-Object System.Windows.Forms.MenuItem
    $LogRotateStatusItem.Text = '[???] Emacs Logs Rotation'
    $ContextMenu.MenuItems.Add($LogRotateStatusItem) | Out-Null

    $AppletIcon.add_MouseDown({
        $Process = Get-EmacsProcessFromPidFile
        if ($Process) {
            $DaemonStatusItem.Text = '[RUNNING] Emacs Daemon'
            $StartDaemonItem.Enabled = $False
            $StopDaemonItem.Enabled = $True
            $RestartDaemonItem.Enabled = $True
        } else {
            $DaemonStatusItem.Text = '[STOPPED] Emacs Daemon'
            $StartDaemonItem.Enabled = $True
            $StopDaemonItem.Enabled = $False
            $RestartDaemonItem.Enabled = $True
        }

        $Job = Get-Job -Name 'LogRotateJob' -ErrorAction SilentlyContinue

        if ($Job) {
            $State = $Job.State.ToUpper()

            if ($State -eq 'RUNNING') {
                $State = 'ENABLED'
            }

            $LogRotateStatusItem.Text = ('[{0}] Logs Rotation' -f $State)
            $EnableLogRotateJobItem.Enabled = $False
            $DisableLogRotateJobItem.Enabled = $True
        } else {
            $LogRotateStatusItem.Text = '[DISABLED] Logs Rotation'
            $EnableLogRotateJobItem.Enabled = $True
            $DisableLogRotateJobItem.Enabled = $False
        }
    })

    $ContextMenu.MenuItems.Add('-') | Out-Null

    # Daemon lifecycle items

    $StartDaemonItem = New-Object System.Windows.Forms.MenuItem
    $StartDaemonItem.Text = 'Start Emacs Daemon...'
    $StartDaemonItem.add_Click({
        Start-InstrumentedBlock 'Failed to start the Emacs daemon' {
            Start-EmacsDaemon -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($StartDaemonItem) | Out-Null

    $StopDaemonItem = New-Object System.Windows.Forms.MenuItem
    $StopDaemonItem.Text = 'Stop Emacs Daemon...'
    $StopDaemonItem.add_Click({
        Start-InstrumentedBlock 'Failed to stop the Emacs daemon' {
            Stop-EmacsDaemon -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($StopDaemonItem) | Out-Null

    $RestartDaemonItem = New-Object System.Windows.Forms.MenuItem
    $RestartDaemonItem.Text = 'Restart Emacs Daemon...'
    $RestartDaemonItem.add_Click({
        Start-InstrumentedBlock 'Failed to restart the Emacs daemon' {
            Restart-EmacsDaemon -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($RestartDaemonItem) | Out-Null

    $ContextMenu.MenuItems.Add('-') | Out-Null

    # Log rotate items

    $EnableLogRotateJobItem = New-Object System.Windows.Forms.MenuItem
    $EnableLogRotateJobItem.Text = 'Enable Log Rotation...'
    $EnableLogRotateJobItem.add_Click({
        Start-InstrumentedBlock 'Failed to enable log rotation' {
            Enable-LogRotateJob -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($EnableLogRotateJobItem) | Out-Null

    $DisableLogRotateJobItem = New-Object System.Windows.Forms.MenuItem
    $DisableLogRotateJobItem.Text = 'Disable Log Rotation...'
    $DisableLogRotateJobItem.add_Click({
        Start-InstrumentedBlock 'Failed to disable log rotation' {
            Disable-LogRotateJob -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($DisableLogRotateJobItem) | Out-Null

    $ContextMenu.MenuItems.Add('-') | Out-Null

    $EditConfigItem = New-Object System.Windows.Forms.MenuItem
    $EditConfigItem.Text = 'Edit Configuration...'
    $EditConfigItem.add_Click({
        Start-InstrumentedBlock 'Failed to edit configuration' {
            Start-Process $CackledaemonConfigLocation
        }
    })
    $ContextMenu.MenuItems.Add($EditConfigItem) | Out-Null

    $OpenWDItem = New-Object System.Windows.Forms.MenuItem
    $OpenWDItem.Text = 'Open Working Directory...'
    $OpenWDItem.add_Click({
        Start-InstrumentedBlock 'Failed to open working directory' {
            Start-Process $CackledaemonWD -ErrorAction Stop
        }
    })
    $ContextMenu.MenuItems.Add($OpenWDItem) | Out-Null

    $ContextMenu.MenuItems.Add('-') | Out-Null

    $ExitItem = New-Object System.Windows.Forms.MenuItem
    $ExitItem.Text = 'Exit'
    $ContextMenu.MenuItems.Add($ExitItem) | Out-Null

    # Lifecycle events

    $AppletForm.add_Load({
        Start-InstrumentedBlock 'Failed to start the Emacs daemon' {
            Start-EmacsDaemon -ErrorAction Stop
        }
        Start-InstrumentedBlock 'Failed to enable log rotation' {
            Enable-LogRotateJob -ErrorAction Stop
        }
    })

    $ExitItem.add_Click({
        if (Get-EmacsDaemon) {
            Start-InstrumentedBlock 'Failed to gracefully shut down Emacs' {
                Stop-EmacsDaemon -ErrorAction Stop
            }
        }

        if (Get-Job -Name 'LogRotateJob' -ErrorAction SilentlyContinue) {
            Start-InstrumentedBlock 'Failed to gracefully shut down log rotation' {
                Disable-LogRotateJob -ErrorAction Stop
            }
        }
        $AppletIcon.Visible = $False
        $AppletIcon.Dispose()
        $AppletForm.Close()
        Remove-Variable -Name AppletForm -Scope Global
        Remove-Variable -Name AppletIcon -Scope Global
    })


    $AppletForm.ShowDialog() | Out-Null
}

#+END_SRC

* Exports
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
Export-ModuleMember `
  -Function @(
      'Clear-ServerFileDirectory',
      'Disable-Job',
      'Disable-LogRotateJob',
      'Enable-Job',
      'Enable-LogRotateJob',
      'Export-EmacsArchive'
      'Get-EmacsDaemon',
      'Get-EmacsDownload',
      'Get-EmacsExeVersion',
      'Get-FileTypeAssociationsConfig',
      'Get-LatestEmacsDownload',
      'Get-ProcessFromPidFile',
      'Get-ShortcutsConfig',
      'Get-StartMenuItems',
      'Get-StartMenuPath',
      'Get-UnmanagedEmacsDaemon',
      'Get-WShell',
      'Get-Workspace',
      'Install-Emacs',
      'Install-EmacsUserEnvironment',
      'Install-Shortcuts',
      'Invoke-Applet',
      'Invoke-LogRotate',
      'New-CackledaemonWD',
      'New-Download',
      'New-EmacsArchive',
      'New-ServerFileDirectory',
      'New-Shortcut',
      'New-Version',
      'New-Workspace',
      'Remove-Workspace',
      'Restart-EmacsDaemon',
      'Set-EmacsAppPathRegistryKeys',
      'Set-EmacsPathEnvVariable',
      'Set-HomeEnvVariable',
      'Set-Shortcut',
      'Start-EmacsDaemon',
      'Stop-EmacsDaemon',
      'Test-EmacsExe',
      'Test-ServerFileDirectory',
      'Update-EmacsInstall',
      'Write-Log',
      'Write-LogDebug',
      'Write-LogError',
      'Write-LogHost',
      'Write-LogInformation',
      'Write-LogVerbose',
      'Write-LogWarning',
      'Write-ProcessToPidFile'
  )`
  -Variable @(
      'CackledaemonConfigLocation',
      'CackledaemonWD'
  )

#+END_SRC
* Manifest
https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psd1
@{
    RootModule = 'Cackledaemon.psm1'

    ModuleVersion = '0.0.17'
    GUID = '10d14360-ee5c-4363-bfe8-f4116a8ce764'

    Author = 'Josh Holbrook'
    Copyright = 'Copyright 2020 Josh Holbrook.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.'

    Description = 'An Emacs installation and runtime manager for Windows'

    PowerShellVersion = '5.1'

    # Modules that must be imported into the global environment prior to importing this module
    # RequiredModules = @()

    # Assemblies that must be loaded prior to importing this module
    RequiredAssemblies = @('System.Windows.Forms')

    # Script files (.ps1) that are run in the caller's environment prior to importing this module.
    # ScriptsToProcess = @()

    # Modules to import as nested modules of the module specified in RootModule/ModuleToProcess
    # NestedModules = @()

    FunctionsToExport = @(
        'Clear-ServerFileDirectory',
        'Disable-Job',
        'Disable-LogRotateJob',
        'Enable-Job',
        'Enable-LogRotateJob',
        'Export-EmacsArchive'
        'Get-EmacsDaemon',
        'Get-EmacsDownload',
        'Get-EmacsExeVersion',
        'Get-FileTypeAssociationsConfig',
        'Get-LatestEmacsDownload',
        'Get-ProcessFromPidFile',
        'Get-ShortcutsConfig',
        'Get-StartMenuItems',
        'Get-StartMenuPath',
        'Get-UnmanagedEmacsDaemon',
        'Get-WShell',
        'Get-Workspace',
        'Install-Emacs',
        'Install-EmacsUserEnvironment',
        'Install-Shortcuts',
        'Invoke-Applet',
        'Invoke-LogRotate',
        'New-CackledaemonWD',
        'New-Download',
        'New-EmacsArchive',
        'New-ServerFileDirectory',
        'New-Shortcut',
        'New-Version',
        'New-Workspace',
        'Remove-Workspace',
        'Restart-EmacsDaemon',
        'Set-EmacsAppPathRegistryKeys',
        'Set-EmacsPathEnvVariable',
        'Set-HomeEnvVariable',
        'Set-Shortcut',
        'Start-EmacsDaemon',
        'Stop-EmacsDaemon',
        'Test-EmacsExe',
        'Test-ServerFileDirectory',
        'Update-EmacsInstall',
        'Write-Log',
        'Write-LogDebug',
        'Write-LogError',
        'Write-LogHost',
        'Write-LogInformation',
        'Write-LogVerbose',
        'Write-LogWarning',
        'Write-ProcessToPidFile'
    )

    CmdletsToExport = @()
    VariablesToExport = @(
        'CackledaemonConfigLocation',
        'CackledaemonWD'
    )

    FileList = @(
        'Cackledaemon.psm1',
        'Cackledaemon.psd1',
        'Configuration.ps1',
        'COPYING',
        'FileTypeAssociations.csv',
        'Shortcuts.csv'
    )
    ModuleList = @('.\Cackledaemon.psm1')

    PrivateData = @{
        PSData = @{
            Tags = @('emacs')
            LicenseUri = 'https://github.com/jfhbrook/cackledaemon/blob/master/COPYING'
            ProjectUri = 'https://github.com/jfhbrook/cackledaemon'

            # A URL to an icon representing this module.
            # IconUri = ''

            # ReleaseNotes of this module
            # ReleaseNotes = ''
        }
    }

    # HelpInfo URI of this module
    # https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-create-a-helpinfo-xml-file?view=powershell-7
    # HelpInfoURI = ''

    # Default prefix for commands exported from this module. Override the default prefix using Import-Module -Prefix.
    # DefaultCommandPrefix = ''

}

#+END_SRC
* Development Tasks
Cackledaemon can be built and published using [[https://github.com/nightroman/Invoke-Build][Invoke-Build]].

#+BEGIN_SRC powershell :tangle Cackledaemon.Build.ps1
task . Clean, Build, Test

#+END_SRC
** Building Cackledaemon
=Invoke-Build= will call Emacs in batch mode to build this project using
~org-babel~. Alternately, you may type ~C-c C-v t~ with this file open in Emacs.

This emacs batch script tangles ~cackledaemon.org~ and generates the ~README.md~:

#+BEGIN_SRC emacs-lisp :tangle build.el
(progn
  (require 'org)
  (require 'ob-tangle)
  (require 'ox-md)

  (with-current-buffer (find-file-noselect "cackledaemon.org")
    (message "Tangling Code...")
    (org-babel-tangle)
    (message "Generating README...")
    (org-export-to-file 'md "README.md"))
  (message "Done."))
#+END_SRC

=Invoke-Build= wraps this in a task which shells out to Emacs:

#+BEGIN_SRC powershell :tangle Cackledaemon.Build.ps1
task Build {
    emacs.exe --batch --load build.el
    Copy-Item 'COPYING' .\Cackledaemon\COPYING -ErrorAction 'SilentlyContinue'
    Remove-Item 'README.md~' -ErrorAction 'SilentlyContinue'
}

#+END_SRC

** Cleanup
#+BEGIN_SRC powershell :tangle Cackledaemon.Build.ps1
task Clean {
    Get-ChildItem './Cackledaemon' | ForEach-Object {
        Remove-Item $_.FullName
    }
    Remove-Item 'README.md' -ErrorAction 'SilentlyContinue'
    Remove-Item 'README.md~' -ErrorAction 'SilentlyContinue'
}

#+END_SRC
** Testing Cackledaemon
#+BEGIN_SRC powershell :tangle Cackledaemon.Build.ps1
task Test {
    powershell -Command Invoke-Pester
}

#+END_SRC
** Publishing Cackledaemon
This project can be published on the Powershell Gallery by running
=Invoke-Build Publish.= In order for it to succeed, there must be a
=.\Secrets.ps1= file that defines =$PowershellGalleryAPIKey= as a valid
Powershell Gallery NuGet API key. This file gets sourced by the ~Publish~ task.

#+BEGIN_SRC powershell :tangle Cackledaemon.Build.ps1
task Publish Build, Test, {
    . .\Secrets.ps1
     Publish-Module -Path .\Cackledaemon\ -NuGetApiKey $PowershellGalleryAPIKey
}
#+END_SRC

* License :export:
Cackledaemon, much like Emacs, is licensed under the terms of the GPL v3 or
newer.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
# Copyright 2020 Josh Holbrook
#
# This file is part of Cackledaemon and not a part of Emacs.
#
# Cackledaemon is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Cackledaemon is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cackledaemon.  if not, see <https://www.gnu.org/licenses/>.


#+END_SRC
