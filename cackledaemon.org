#+TITLE: Cackledaemon - An Emacs Installation and Runtime Manager for Windows
#+AUTHOR: Josh Holbrook
#+OPTIONS: tags:nil toc:nil

* Cackledaemon :export:
#+BEGIN_QUOTE
Oh-ho-ho! Swirly Photoshop magic! I bet this thing could release some serious
cackledemons!

-- Strong Bad
#+END_QUOTE

Anyone who has used a fully configured [[https://www.gnu.org/software/emacs/][Emacs]] install such as [[https://www.spacemacs.org/][Spacemacs]] or [[https://github.com/hlissner/doom-emacs][Doom]]
knows that Emacs can take a long time to initially boot. This isn't for a lack
of trying - in fact, the source code for Doom is half speed hacks and I highly
encourage anybody hacking on Emacs to take a look.

The truth is that Emacs is less a code editor and more of a *framework* for
*writing text-based applications*. I like to compare it to [[https://nodejs.org][Node.js]] in this
regard, which, while really good at being a webserver is no [[https://www.nginx.com/][NGINX]], but instead a
runtime where you can import lots of tiny pieces of functionality a la carte to
make your own webserver. Any one of these configurations does exactly this - it
installs packages from the internet, requires them and uses [[https://www.gnu.org/software/emacs/manual/html_node/eintr/][Emacs Lisp]] to create
a complete application. Spacemacs and Doom are built similarly, but feel
different because they *are* in fact meaningfully different.

Just as you don't want to load the JavaScript runtime for every request (this is
how non-Node webservers [[https://en.wikipedia.org/wiki/Common_Gateway_Interface][used to do in the olden days]] and trust me it was not
very good) you don't really want to load all of Emacs every time you open a file
either. It's less than ideal.

Luckily for us, Emacs can be ran [[https://www.emacswiki.org/emacs/EmacsAsDaemon][as a daemon]] and connected to via a client,
typically ~emacsclient~. In Linux and [[https://www.freedesktop.org/wiki/Software/systemd/][systemd]] this works seamlessly - often you
can run =systemctl start --user emacs= and be off to the races. In OSX it's only
a little harder - you [[https://www.emacswiki.org/emacs/EmacsAsDaemon#toc8][copy-paste a plist file from the wiki]], pull some very
minor shenanigans and have a mostly working daemon.

In Windows it's a bit more of a mess. This is because the Windows abstractions
for processes and services are wildly divergent from those in nix-like
environments such as Linux and OSX. Init systems like systemd run and manage
normal process, meanwhile in Windows services are in fact [[https://docs.microsoft.com/en-us/dotnet/framework/windows-services/walkthrough-creating-a-windows-service-application-in-the-component-designer][special programs]] that
[[https://docs.microsoft.com/en-us/dotnet/api/system.serviceprocess?view=netframework-4.8][expose an alternate interface]] to that of the standard process. The upshot is
that any standard process that one wants to run as a Windows service needs to be
wrapped in one of these special programs, complete with bespoke abstractions for
process management, log management and so on.

Alternately, arbitrary processes may be [[https://support.microsoft.com/en-us/help/4026268/windows-10-change-startup-apps][configured to start on user login]].
Practically speaking, this is how most persistent applications are ran in
Windows, and in fact the [[https://www.emacswiki.org/emacs/EmacsMsWindowsIntegration#toc8][approach documented in the wiki]] does exactly this - it
uses a Powershell script to generate a very simple [[https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands][batch file]] that cleans up
server state from the prior run and then spawns the Emacs daemon.

This works OK. However, there are some downsides. if the Emacs daemon crashes
for any reason, there's no signal other than ~emacsclient~ mysteriously not
working; any logs that come out of the Emacs daemon are lost to the aether; and
straightforward lifecycle actions that can be done casually with systemd (start,
top, restart, status) are very non-ergonomic.

Luckily, [[https://docs.microsoft.com/en-us/powershell/scripting/overview][PowerShell]] has our back. PowerShell is a shockingly good language - it
performs admirably as a shell and yet scales to general purpose use, even being
capable of making proper [[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes][.NET classes]]. More to the point, it's very good at
[[https://docs.microsoft.com/en-us/powershell/scripting/samples/managing-processes-with-process-cmdlets][managing processes]] and has [[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/background-jobs][special support for background jobs]], as well as being
able to [[https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.notifyicon][instantiate and manage tray icons]] via [[https://docs.microsoft.com/en-us/dotnet/framework/winforms/][Windows Forms]]. All it needs is a
little elbow grease!

Cackledaemon is a PowerShell module that intends to be a solution for managing
such an instance of the Emacs daemon for Windows. It includes functions for
starting, stopping and restarting the Emacs daemon, functions and jobs for log
management and rotation, and a tray icon for a lil' point-and-click action and
notifications for if/when Emacs exits unexpectedly.

* Working Directory
Cackledaemon needs a place to store logs and process metadata. For this purpose,
we use a folder inside =APPDATA=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
$CackledaemonWD = Join-Path $env:APPDATA 'cackledaemon'

function New-CackledaemonWD {
    New-Item -Path $CackledaemonWD -ItemType directory
}

#+END_SRC

* Logging
** Settings
These are the settings for log location and rotation.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
$CackledaemonLogFile = Join-Path $CackledaemonWD 'Cackledaemon.log'
$EmacsStdOutLogFile = Join-Path $CackledaemonWD 'EmacsStdout.log'
$EmacsStdErrLogFile = Join-Path $CackledaemonWD 'EmacsStderr.log'
$LogSize = 1mb
$LogRotate = 4
$LogCheckTime = 2  # Seconds

#+END_SRC
** Logger
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Write-Log {
    param(
        [Parameter(Position=0)]
        [string]$Message,
        [string]$Level = 'Verbose',
        [string]$Category = 'NotSpecified',
        [string]$CategoryActivity,
        [string]$CategoryReason
    )

    if (-not @('Debug', 'Verbose', 'Warning', 'Error').Contains($Level)) {
        Write-Warning ('Write-Log called with unrecognized level {0}' -f $Level)
        $Level = 'Warning'
    }

    $Line = ('[{0}] {1}: {2}' -f (Get-Date -Format o), $Level, $Message)

    Add-Content $CackledaemonLogFile -value $Line

    if ($Level -eq 'Debug') {
        Write-Debug $Line
    } elseif ($Level -eq 'Verbose') {
        Write-Verbose $Line
    } elseif ($Level -eq 'Warning') {
        Write-Warning $Line
    } elseif ($Level -eq 'Error') {
        Write-Error -Message $Line `
          -Category $Category `
          -CategoryActivity $CategoryActivity `
          -CategoryReason $CategoryReason
    }
}

function Write-LogDebug {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Debug
}

function Write-LogVerbose {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Verbose
}

function Write-LogWarning {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Warning
}

function Write-LogError {
    [Parameter(Position=0)]
    param([string]$Message)

    Write-Log $Message -Level Error
}

#+END_SRC
** Log Rotation
For log rotation, we use a PowerShell job. It more or less tries to emulate a
typical logrotate config - it rotates the log if it's at or over a certain size,
retains some finite count of log files, and drops the last one if necessary. It
will do this every configured amount of seconds indefinitely.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Get-CackledaemonLogRotateJob {
    Get-Job -Name 'CackledaemonLogRotateJob' -ErrorAction SilentlyContinue
}

function Start-CackledaemonLogRotateJob {
    if (Get-CackledaemonLogRotateJob | Where-Object { $_.State -eq 'Running' }) {
        Write-LogError `
          -Message 'The Cackledaemon log rotate job is already running.' `
          -Category ResourceExists `
          -CategoryActivity 'Start-CackledaemonLogRotateJob' `
          -CategoryReason ResourceExistsException
    }

    Start-Job `
    -Name 'CackledaemonLogRotateJob' `
    -InitializationScript {
        Import-Module Cackledaemon
    } `
    -ScriptBlock {
        Set-Location $CackledaemonWD

        while ($true) {
            @($CackledaemonLogFile, $EmacsStdoutLogFile, $EmacsStdErrLogFile) | ForEach-Object {
                $LogFile = $_

                if ((Get-Item $LogFile).Length -ge $LogSize) {
                    Write-LogVerbose ('Rotating {0}...' -f $LogFile)

                    ($LogRotate..0) | ForEach-Object {
                        $Current = $(if ($_) {
                          '{0}.{1}' -f $LogFile, $_
                        } else { $LogFile })

                        $Next = '{0}.{1}' -f $LogFile, ($_ + 1)

                        if (Test-Path $Current) {
                            Write-Log ('Copying {0} to {1}...' -f $Current, $Next)

                            Copy-Item -Path $Current -Destination $Next
                        }
                    }

                    Write-LogVerbose ('Truncating {0}...' -f $LogFile)

                    Clear-Content $LogFile

                    $StaleLogFile = '{0}.{1}' -f ($LogRotate + 1)

                    if (Test-Path $StaleLogFile) {
                        Write-LogVerbose ('Removing {0}...' -f $StaleLogFile)

                        Remove-Item $StaleLogFile
                    }

                    Write-LogVerbose 'Done.'
                }
            }
            Write-LogDebug ('No need to rotate logs. Sleeping for {0} seconds.' -f $LogCheckTime)
            Start-Sleep -Seconds $LogCheckTime
        }
    }
}

function Stop-CackledaemonLogRotateJob {
    Stop-Job -Name 'CackledaemonLogRotateJob'
}

function Remove-CackledaemonLogRotateJob {
    Remove-Job -Name 'CackledaemonLogRotateJob'
}

#+END_SRC
* Daemon Management

Need to be able to configure the server file, since the defaults break w/ chemacs
https://www.gnu.org/software/emacs/manual/html_node/emacs/TCP-Emacs-server.html

https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/start-process?view=powershell-7
https://mcpmag.com/articles/2017/09/07/creating-a-balloon-tip-notification-using-powershell.aspx
https://github.com/proxb/PowerShell_Scripts/blob/master/Invoke-BalloonTip.ps1
https://community.spiceworks.com/topic/1874769-how-to-monitor-services-with-powershell
https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/convertfrom-json?view=powershell-7
** Process State Serialization
In order to do basic monitoring of the Emacs daemon, we serialize the process
object to and from a JSON file inside the working directory. We only need to
save the ID, but storing the entire process object is easier.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

$PidFile = Join-Path $CackledaemonWD 'DaemonPidFile.json'

function Write-EmacsProcessToPidFile {
    param([System.Diagnostics.Process]$Process)

    ($Process).Id | ConvertTo-Json | Out-File $PidFile
}

function Get-EmacsProcessFromPidFile {
    if (-not (Test-Path $PidFile)) {
        return $null
    }

    $Id = (Get-Content $PidFile | ConvertFrom-Json)

    if (-not $Id) {
        Remove-Item $PidFile
        return $null
    }

    return Get-Process -Id $Id -ErrorAction SilentlyContinue
}

#+END_SRC
** Checking For Existing Daemons
It would probably be bad to try to start an Emacs daemon if one is already
running.

if an Emacs daemon is being managed, then retrieving the process state should be
successful and we can simply check to make sure that =Get-EmacsProcessFromPidFile=
returns a non-=$null= value. However, it's also possible to start the Emacs
daemon out-of-band, in which case we probably don't want to get involved either.
To check for this, we use [[https://docs.microsoft.com/en-us/powershell/module/cimcmdlets/get-ciminstance?view=powershell-7][CIM]] to find emacs processes and then check to see if
any of them have ~--daemon~ in their command line args. We intentionally punt on
the edge case of searching for emacs instances *not* started with the ~--daemon~
but which have called =(run-server)=.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Get-UnmanagedEmacsDaemons () {
    $ManagedProcess = $(Get-EmacsProcessFromPidFile)
    return Get-CimInstance -Query "
        SELECT
          ,*
        FROM Win32_Process
        WHERE
          Name = 'emacs.exe' OR Name = 'runemacs.exe'
    " | Where-Object {
        $_.CommandLine.Contains("--daemon")
    } | ForEach-Object {
        Get-Process -Id ($_.ProcessId)
    } | Where-Object { -not ($_.Id -eq $ManagedProcess.Id) }
}

#+END_SRC
** Start the Emacs Daemon
This function launches the Emacs daemon (if it's not running already) with
sensible parameters and stores process info so we can do basic monitoring.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Start-EmacsDaemon {
    [CmdletBinding()]
    param ([switch]$Wait)

    $Process = $(Get-EmacsProcessFromPidFile)

    if ($Process) {
        Write-LogError `
          -Message 'The Emacs daemon is already running and being managed.' `
          -Category ResourceExists `
          -CategoryActivity 'Start-EmacsDaemon' `
          -CategoryReason ManagedResourceExistsException

    } elseif ($(Get-UnmanagedEmacsDaemons)) {
        Write-LogError `
          -Message 'An unmanaged Emacs daemon is running.' `
          -Category ResourceExists `
          -CategoryActivity 'Start-EmacsDaemon' `
          -CategoryReason UnmanagedResourceExistsException
    } else {
        Write-LogVerbose 'Starting the Emacs daemon...'

        $Process = Start-Process `
        -FilePath 'emacs.exe' `
        -ArgumentList '--daemon' `
        -NoNewWindow `
        -RedirectStandardOut $EmacsStdOutLogFile `
        -RedirectStandardError $EmacsStdErrLogFile `
        -PassThru

        Write-EmacsProcessToPidFile $Process

        if ($Wait) {
            Write-Verbose 'Waiting for Emacs daemon to exit...'
            $Process = Wait-Process -InputObject $Process
        }

        Write-Verbose 'Done.'

        return $Process
    }
}

#+END_SRC
** Get the Emacs Daemon
We actually already have this, its name just isn't very ergonomic. We'll set it
as an alias here for convenience.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Get-EmacsDaemon {
    [CmdletBinding()]
    param()

    Get-EmacsProcessFromPidFile
}

#+END_SRC
** Stop the Emacs Daemon
Stopping the process is simply a matter of retrieving the process state from
disk and attempting to stop the process.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function Stop-EmacsDaemon {
    [CmdletBinding()]
    param()

    $Process = Get-EmacsProcessFromPidFile

    if (-not $Process) {
        Write-LogError `
          -Message "A managed Emacs daemon isn't running and can not be stopped!" `
          -Category ResourceUnavailable `
          -CategoryActivity 'Stop-EmacsDaemon' `
          -CategoryReason ManagedResourceUnavailableException
    } else {
        Write-LogVerbose 'Stopping the Emacs daemon...'

        Stop-Process -InputObject $Process

        Write-EmacsProcessToPidFile $null

        Write-LogVerbose 'Done.'
    }
}

#+END_SRC
** Restart the Emacs Daemon
From here, restarting is easy - first stop the process, then start it again.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1

function Restart-EmacsDaemon {
    Stop-EmacsDaemon
    Start-EmacsDaemon
}
#+END_SRC
* Installation Stuff
It turns out that installing emacs is unzipping a zipball, running a magic
program and manually doing a bunch of bullshit. I should just automate
installing and checking for updates too.

https://lists.gnu.org/archive/html/help-gnu-emacs/2004-03/msg00168.html
https://www.gnu.org/software/emacs/manual/html_node/emacs/Windows-Startup.html

#+BEGIN_SRC powershell
(
    Invoke-WebRequest https://mirrors.syringanetworks.net/gnu/emacs/windows/
).Links.Href | Where-Object { $_.StartsWith('emacs-') } | ForEach-Object {
    $_ -match 'emacs-(\d+)/'
    return $Matches[1]
}
#+END_SRC
* Desktop Applet
Cackledaemon uses Windows Forms to create a desktop tray applet.

Note that there are a few things that may seem a little odd but are necessary:

- Using global variables. This is because code running outside of this
  function's scope, including certain kinds of callbacks, need access to these
  properties.
- Creating and showing a Form even though nothing is being drawn to it. If the
  form doesn't exist when we try to generate the context menu, very strange
  things happen.

The vast majority of menu items launch a separate PowerShell instance which then
imports Cackledaemon and attempts to run the appropriate function. As such, the
module needs to be properly installed in PowerShell's module search paths in
order for this applet to function properly.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
Add-Type -AssemblyName System.Windows.Forms

function Invoke-CackledaemonApplet {
    [CmdletBinding()]
    param()

    # The parent Form
    $Global:AppletForm = New-Object System.Windows.Forms.Form
    $AppletForm.Visible = $False
    $AppletForm.WindowState = "minimized"
    $AppletForm.ShowInTaskbar = $False

    # The NotifyIcon
    $Global:AppletIcon = New-Object System.Windows.Forms.NotifyIcon
    $AppletIcon.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon(
        (Get-Command 'emacs.exe').Path
    )
    $AppletIcon.Visible = $True

    $NotifyTimeout = 5000

    # The right-click menu
    $ContextMenu = New-Object System.Windows.Forms.ContextMenu
    $AppletIcon.ContextMenu = $ContextMenu

    # Status items
    $DaemonStatusItem = New-Object System.Windows.Forms.MenuItem
    $DaemonStatusItem.Index = 0
    $DaemonStatusItem.Enabled = $False
    $DaemonStatusItem.Text = '[???] Emacs Daemon'
    $ContextMenu.MenuItems.Add($DaemonStatusItem) | Out-Null

    $LogRotateStatusItem = New-Object System.Windows.Forms.MenuItem
    $LogRotateStatusItem.Enabled = $False
    $LogRotateStatusItem.Text = '[???] Emacs Logs Rotation'
    $ContextMenu.MenuItems.Add($LogRotateStatusItem) | Out-Null

    $AppletIcon.add_MouseDown({
        $Process = Get-EmacsProcessFromPidFile
        if ($Process) {
            $DaemonStatusItem.Text = '[RUNNING] Emacs Daemon'
        } else {
            $DaemonStatusItem.Text = '[STOPPED] Emacs Daemon'
        }

        $Job = Get-CackledaemonLogRotateJob
        if (-not $Job) {
            $LogRotateStatusItem.Text = '[DISABLED] Logs Rotation'
        } else {
            $LogRotateStatusItem.Text = ('[{0}] Logs Rotation' -f $Job.State.ToUpper())
        }
    })

    $ContextMenu.MenuItems.Add('-') | Out-Null

    # Daemon lifecycle items

    $StartDaemonItem = New-Object System.Windows.Forms.MenuItem
    $StartDaemonItem.Text = 'Start Emacs Daemon...'
    $StartDaemonItem.add_Click({
        try {
            Start-EmacsDaemon
        } catch {
            $AppletIcon.BalloonTipIcon = [System.Windows.Forms.ToolTipIcon]::Warning
            $AppletIcon.BalloonTipTitle = 'Failed to start the Emacs daemon'
            $AppletIcon.BalloonTipText = $_.Exception
            $AppletIcon.ShowBalloonTip($NotifyTimeout)
        }
    })
    $ContextMenu.MenuItems.Add($StartDaemonItem) | Out-Null

    $StopDaemonItem = New-Object System.Windows.Forms.MenuItem
    $StopDaemonItem.Text = 'Stop Emacs Daemon...'
    $StopDaemonItem.add_Click({
        try {
            Stop-EmacsDaemon
        } catch {
            $AppletIcon.BalloonTipIcon = [System.Windows.Forms.ToolTipIcon]::Warning
            $AppletIcon.BalloonTipTitle = 'Failed to stop the Emacs daemon'
            $AppletIcon.BalloonTipText = $_.Exception
            $AppletIcon.ShowBalloonTip($NotifyTimeout)
        }
    })
    $ContextMenu.MenuItems.Add($StopDaemonItem) | Out-Null

    $RestartDaemonItem = New-Object System.Windows.Forms.MenuItem
    $RestartDaemonItem.Text = 'Restart Emacs Daemon...'
    $RestartDaemonItem.add_Click({
        try {
            Restart-EmacsDaemon
        } catch {
            $AppletIcon.BalloonTipIcon = [System.Windows.Forms.ToolTipIcon]::Warning
            $AppletIcon.BalloonTipTitle = 'Failed to restart the Emacs daemon'
            $AppletIcon.BalloonTipText = $_.Exception
            $AppletIcon.ShowBalloonTip($NotifyTimeout)
        }
    })
    $ContextMenu.MenuItems.Add($RestartDaemonItem) | Out-Null

    $ContextMenu.MenuItems.Add('-') | Out-Null

    # Log rotate items

    $EnableLogRotateJobItem = New-Object System.Windows.Forms.MenuItem
    $EnableLogRotateJobItem.Text = 'Enable Log Rotation...'
    $EnableLogRotateJobItem.add_Click({
        try {
            Start-CackledaemonLogRotateJob
        } catch {
            $AppletIcon.BalloonTipIcon = [System.Windows.Forms.ToolTipIcon]::Warning
            $AppletIcon.BalloonTipTitle = 'Failed to enable log rotation'
            $AppletIcon.BalloonTipText = $_.Exception
            $AppletIcon.ShowBalloonTip($NotifyTimeout)
        }
    })
    $ContextMenu.MenuItems.Add($EnableLogRotateJobItem) | Out-Null

    $DisableLogRotateJobItem = New-Object System.Windows.Forms.MenuItem
    $DisableLogRotateJobItem.Text = 'Disable Log Rotation...'
    $DisableLogRotateJobItem.add_Click({
        try {
            Stop-CackledaemonLogRotateJob
            Remove-CackledaemonLogRotateJob
        } catch {
            $AppletIcon.BalloonTipIcon = [System.Windows.Forms.ToolTipIcon]::Warning
            $AppletIcon.BalloonTipTitle = 'Failed to disable log rotation'
            $AppletIcon.BalloonTipText = $_.Exception
            $AppletIcon.ShowBalloonTip($NotifyTimeout)
        }
    })
    $ContextMenu.MenuItems.Add($DisableLogRotateJobItem) | Out-Null

    $ContextMenu.MenuItems.Add('-') | Out-Null

    $OpenWDItem = New-Object System.Windows.Forms.MenuItem
    $OpenWDItem.Text = 'Open Working Directory...'
    $OpenWDItem.add_Click({
        Start-Process $CackledaemonWD
    })
    $ContextMenu.MenuItems.Add($OpenWDItem) | Out-Null

    $ContextMenu.MenuItems.Add('-') | Out-Null

    $ExitItem = New-Object System.Windows.Forms.MenuItem
    $ExitItem.Text = 'Close Tray Applet'
    $ExitItem.add_Click({
        $AppletIcon.Visible = $False
        $AppletIcon.Dispose()
        $AppletForm.Close()
        Remove-Variable -Name AppletForm -Scope Global
        Remove-Variable -Name AppletIcon -Scope Global
    })
    $ContextMenu.MenuItems.Add($ExitItem) | Out-Null


    $AppletForm.ShowDialog() | Out-Null
}

#+END_SRC

Code with access to the =$AppletIcon= global variable can send notifications.
This is generally called asynchronously.

Long term it may turn out that trying to use this function won't actually work
and I'll just have to do the two member definitions + method call.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
function New-Notification {
    param (
        [string]$hed,
        [string]$dek
    )

    if ($AppletIcon) {
        $AppletIcon.BalloonTipTitle = $hed
        $AppletIcon.BalloonTipText = $dek
        $AppletIcon.ShowBalloonTip(5000)
    } else {
        Write-Error -Message "The applet isn't open so we can't send a notification."
    }
}

#+END_SRC
* Exports
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
Export-ModuleMember `
  -Function @(
      'Get-CackledaemonLogRotateJob',
      'Start-CackledaemonLogRotateJob',
      'Stop-CackledaemonLogRotateJob',
      'Remove-CackledaemonLogRotateJob',
      'Start-EmacsDaemon',
      'Get-EmacsDaemon',
      'Stop-EmacsDaemon',
      'Restart-EmacsDaemon',
      'Get-UnmanagedEmacsDaemons',
      'Get-EmacsProcessFromPidFile',
      'Invoke-CackledaemonApplet'
  ) `
  -Variable @(
      'CackledaemonWD'
  )

#+END_SRC
* Manifest
https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-write-a-powershell-module-manifest?view=powershell-7
#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psd1
@{
    RootModule = 'Cackledaemon.psm1'

    ModuleVersion = '0.0.12'
    GUID = '10d14360-ee5c-4363-bfe8-f4116a8ce764'

    Author = 'Josh Holbrook'
    Copyright = 'Copyright 2020 Josh Holbrook.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.'

    Description = 'An Emacs installation and runtime manager for Windows'

    # Modules that must be imported into the global environment prior to importing this module
    # RequiredModules = @()

    # Assemblies that must be loaded prior to importing this module
    RequiredAssemblies = @('System.Windows.Forms')

    # Script files (.ps1) that are run in the caller's environment prior to importing this module.
    # ScriptsToProcess = @()

    # Modules to import as nested modules of the module specified in RootModule/ModuleToProcess
    # NestedModules = @()

    FunctionsToExport = @(
        'Get-CackledaemonLogRotateJob',
        'Start-CackledaemonLogRotateJob',
        'Stop-CackledaemonLogRotateJob',
        'Remove-CackledaemonLogRotateJob',
        'Start-EmacsDaemon',
        'Get-EmacsDaemon',
        'Stop-EmacsDaemon',
        'Restart-EmacsDaemon',
        'Get-UnmanagedEmacsDaemons',
        'Get-EmacsProcessFromPidFile',
        'Invoke-CackledaemonApplet'
    )

    CmdletsToExport = @()
    VariablesToExport = @(
        'CackledaemonWD'
    )

    FileList = @('Cackledaemon.psm1', 'Cackledaemon.psd1', 'COPYING')
    ModuleList = @('.\Cackledaemon.psm1')

    PrivateData = @{
        PSData = @{
            Tags = @('emacs')
            LicenseUri = 'https://github.com/jfhbrook/cackledaemon/blob/master/COPYING'
            ProjectUri = 'https://github.com/jfhbrook/cackledaemon'

            # A URL to an icon representing this module.
            # IconUri = ''

            # ReleaseNotes of this module
            # ReleaseNotes = ''
        }
    }

    # HelpInfo URI of this module
    # https://docs.microsoft.com/en-us/powershell/scripting/developer/module/how-to-create-a-helpinfo-xml-file?view=powershell-7
    # HelpInfoURI = ''

    # Default prefix for commands exported from this module. Override the default prefix using Import-Module -Prefix.
    # DefaultCommandPrefix = ''

}

#+END_SRC
* Development Tasks
Cackledaemon can be built and published using [[https://github.com/nightroman/Invoke-Build][Invoke-Build]].
** Building Cackledaemon
=Invoke-Build= will call Emacs in batch mode to build this project using
~org-babel~. Alternately, you may type ~C-c C-v t~ with this file open in Emacs.

This emacs batch script tangles ~cackledaemon.org~ and generates the ~README.md~:

#+BEGIN_SRC emacs-lisp :tangle build.el
(progn
  (require 'org)
  (require 'ob-tangle)
  (require 'ox-md)

  (with-current-buffer (find-file-noselect "cackledaemon.org")
    (message "Tangling Code...")
    (org-babel-tangle)
    (message "Generating README...")
    (org-export-to-file 'md "README.md"))
  (message "Done."))
#+END_SRC

=Invoke-Build= wraps this in a task which shells out to Emacs:

#+BEGIN_SRC powershell :tangle Cackledaemon.build.ps1
task . Build

task Build {
    emacs.exe --batch --load build.el
    Remove-Item README.md~
}

#+END_SRC
** Publishing Cackledaemon
This project can be published on the Powershell Gallery by running
=Invoke-Build Publish.= In order for it to succeed, there must be a
=.\Secrets.ps1= file that defines =$PowershellGalleryAPIKey= as a valid
Powershell Gallery NuGet API key. This file gets sourced by the ~Publish~ task.

#+BEGIN_SRC powershell :tangle Cackledaemon.build.ps1
task Publish Build, {
    . .\Secrets.ps1
     Publish-Module -Path .\Cackledaemon\ -NuGetApiKey $PowershellGalleryAPIKey
}
#+END_SRC

* License :export:
Cackledaemon, much like Emacs, is licensed under the terms of the GPL v3 or
newer.

#+BEGIN_SRC powershell :tangle ./Cackledaemon/Cackledaemon.psm1
# Copyright 2020 Josh Holbrook
#
# This file is part of Cackledaemon.
#
# Cackledaemon is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Cackledaemon is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cackledaemon.  if not, see <https://www.gnu.org/licenses/>.


#+END_SRC
